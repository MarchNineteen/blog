---
title: 秒杀场景
date: 2019-12-20 
desc:
keywords: 秒杀
categories: [active]
---
# 秒杀场景可能遇到的问题（用户流程角度）

- 问题一.即将到秒杀时间，同时请求网页过多，打开网页速度慢

- 问题二.进入页面后，未到秒杀时间，用户一直点击购买按钮，一直发起请求

- 问题三.用户拿到接口地址，恶意请求（用脚本）

- 问题四.超卖现象

- 问题五.数据库请求过多，数据库奔溃

# 解决方案

## 问题一

- 针对于动态页面（jsp，ftl）可以把整个页面存储在redis中，避免页面渲染。

- 前后端分离项目，页面单独部署，使用cdn加速，资源静态
- 打开网页速度慢，除了页面的原因外，后台请求返回慢也有很大的关系，简单说就是后台高并发能力不足，一遇到此类场景，cpu，内存飚升，程序响应慢。单台tomcat并发量不足，可以集群部署然后使用nginx做负载均衡，恶意请求也可以在此拦截。
- 后台对请求限流

## 问题二

- 页面按钮控制，未到时间按钮不能点击，需要页面定时请求后台获取最新的北京时间，不能以页面本地时间为准
- 在用户点击过后，再把按钮设置无效，防止无效重复点击

## 问题三

接口地址动态化，通过MD5之类的加密算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过

## 问题四

### 处理流程：

典型的读多先少场景，使用mysql等nosql，把库存存入redis中，进行库存预热。通过三级缓冲保证数据库压力，本地内存标记，库存修改在redis中进行预存，接着通过mq进行异步下单，处理数据库。若下单成功，页面轮询接口返回订单处理状态。

### 解决超卖方案

- 防止数据库内存为0，在修改时进行库存判断，大于0才更新。
- 用户id与商品id建立唯一所以，防止同一用户重复购买同一件商品。
- 实现乐观锁，商品信息中年增加version字段。每次更新时version+1，更新时候带上版本号，当提交前版本号等于更新前版本号，说明此时没有被其他线程影响到，正常更新，如果冲突了则不会进行提交更新。当库存是足够的情况下发生乐观锁冲突就进行一定次数的重试。

一整套解决方案

![秒杀](https://user-gold-cdn.xitu.io/2019/11/16/16e72d24415cb009?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 产生更多的问题

- redis集群，数据同步,分布式锁等
- mq高可用
- 限流&降级&熔断&隔离
- 分布式服务，事务处理。
