---
title: jvm学习（一）
date: 2018-10-31 
desc: jvm知识要点,jvm学习笔记
keywords: jvm
categories: [JVM]
---

# 一：内存区域

![内存区域](/uploads/java/jvm/jvm内存区域.jpg)

## 线程私有(针对于方法)：

   程序计数器（Program Count Register）：如果线程正在执行java方法，计数器记录正在执行的虚拟机字节码地址；Native方法，值为空。

   虚拟机栈（Vm Stack）: 描述Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于存储**局部变量表**、操作数栈、动态链接、方法出口等。
   - 人们常说的Java内存分为堆内存（Heap）和栈内存（Stack），这个栈就是虚拟机栈，或者说是机栈中局部变量表部分。
   - 局部变量表（虚拟机栈）存放编译器可知的**基本数据类型**和**对象引用**。
   - 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

   本地方法栈（Native Method Stack）：作用与虚拟机栈相似，本地方法栈执行Native方法。

## 线程共享（针对于Class）：

   堆（Heap）：存放**所有对象实例**以及**数组**，是垃圾回收的主要区域。
   - 现在垃圾收集器基本采用**分代收集算法**，主要思想为针对不用类型的对象采取不同的垃圾回收算法，可将堆分为**新生代**和**老年代**，还可细分。
   - 从内存分配的角度，堆可能分出多个线程私有的分配缓冲区(TLAB)，只是为了更好回收内存，更快分配内存，存储对象不变。
   - 堆无需连续内存，可以动态增加，增加失败会抛出OutOfMemoryError 异常。可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。java -Xms1M -Xmx2M。

   方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
   - 和堆一样不需要连续的内存，还可以选择不实现垃圾回收，对这一区域内存回收目标主要是针对常量池和类型的卸载，一般难以实现，效果较差。
   - HotSpot 虚拟机把它当成永久代来进行垃圾回收。但是很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。

   运行时常量池（Runtime Constant Pool）：是方法区的一部分。Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。
   - 具备动态性，除了再编译器生成的常量放入这一区域外，还允许动态生成。常量不仅仅再编译期间才能产生，在运行时也可能产生新的常量，例如String类的intern()。
   - 受到方法区内存大小限制，无法申请到内存时会抛出OutOfMemoryError异常。

   直接内存：不是虚拟机运行时数据区的一部分。jdk1.4中引入NIO，可以直接使用native函数库分配堆外的内存，然后通过一个存储在Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作，避免了Java堆和Native对中来回复制数据显著提高性能。

# 二：HotSpot虚拟机对象

## 对象的创建

   空间划分（内存分配）：堆采用的垃圾收集器是否带有压缩整理功能-->堆是否规整-->内存的分配方式，规整采用**指针碰撞**方法，否则采用**空闲列表**方式

   对象在创建中是否频繁（并发问题）：
   - 同步处理，CAS加失败重试保证原子性
   - 本地线程分配缓冲区（TLAB）：每个线程在Java堆中预先分配一小块内存。线程私有内存。
   - 内存分配完成后，进行对象实例字段的初始化（不包括对象头，内存空间都为零值）；若使用TLAB，则可提前在TLAB中分配。

   对象头设置：存放类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。虚拟机当前运行状态（如是否启用偏向锁）不同，对象头有不同的设置方式。

   上述工作完成后，虚拟机角度新的对象已经产生，程序角度对象创建刚刚开始--<init>方法还未执行。

## 对象的内存布局

   ![对象在内存布局](/uploads/java/jvm/对象在内存布局.jpg)

## 对象的访问定位

   Java程序通过栈上的reference（指向对象的引用）数据操作堆上的具体数据。访问方式由虚拟机实现。主流方式有2种。
   - 句柄：堆中划分句柄池，reference存储对象的句柄地址，句柄包含**对象实例数据**与**类型数据（类数据）**各自的具体地址。
   优点：在对象被移动时（垃圾收集时移动对象是非常普遍的行为）只会改变句柄中的实例数据指针，reference本事不需要修改。
   - 直接指针：reference存储的直接是对象的地址，对象的实例数据中要放置访问类型数据的指针。
   优点：速度快，节省了一次指针定位的时间开销。

# 三：垃圾收集

   垃圾收集需要考虑三个问题：**回收哪些内存**，**什么时候回收**，**怎么回收**

   垃圾收集器主要针对堆和方法区进行。

   程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。

## 判断一个对象是否可被回收（回收哪些内存）

   ### 1.引用计数算法
   给对象添加一个引用计数器，当对象增加引用时就加一，失效一个引用时就减一。引用计数器为0的对象表示可以回收。 
   - 由于存在循环引用，引用计数器永远不为0，导致永远不会被回收。

   ### 2.可达性分析算法
   通过 Roots作为起点，能够到达的对象被视为存活，不可达的对象可以回收。
   ![可达性分析算法](/uploads/java/jvm/可达性分析算法.png)
   
   可作为GC Roots的对象：（全局性引用如常量和类静态变量，应用上下文如帧栈中的本地变量表）
   - 虚拟机栈（帧栈中的本地变量两）中引用的对象
   - 方法区中的类静态属性引用的对象
   - 方法区中常量引用的对象
   - 本地方法栈中的JNI（即一般说的Native方法）引用的对象。

   ### 3.对象生存还是死亡（finalize()方法）
   在可达性分析算法过程中不可达的对象并非一定会被回收。在可达性分析算法被认为无引用链后，需要2步才能真正宣告对象已死。
   - 进行一次筛选，筛选条件为对象是否有必要执行finalize()方法，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。
   执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。
   - 若未覆盖finalize方法，则直接将其回收。

   自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。

   ### 4.方法区回收
   因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。主要是对常量池的回收和对类的卸载。
   
   在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。
   
   类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：
   - 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。
   - 加载该类的 ClassLoader 已经被回收。
   - 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。
   
   可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。
    
## 引用类型
    
   无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。
    
   Java 提供了四种强度不同的引用类型。
   
   ### 1.强引用
   被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。 
   
    Object obj = new Object();
   ### 2.软引用
   被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。 
   
    Object obj = new Object();
    SoftReference<Object> sf = new SoftReference<Object>(obj);
    obj = null;  // 使对象只被软引用关联
   ### 3.弱引用
   被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来实现弱引用。
       
    Object obj = new Object();
    SoftReference<Object> sf = new SoftReference<Object>(obj);
    obj = null;  // 使对象只被软引用关联

   ### 4.虚引用
   被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来实现弱引用。
        
    Object obj = new Object();
    SoftReference<Object> sf = new SoftReference<Object>(obj);
    obj = null;  // 使对象只被软引用关联

## 垃圾收集算法（怎么回收）

   ### 1.标记 - 清除
   ![标记-清除](/uploads/java/jvm/标记-清除.jpg)
   标记要回收的对象，然后清除。
   
   不足：
   
   标记和清除过程效率都不高；
   会产生大量不连续的内存碎片，导致无法给大对象分配内存。
   
   ### 2.标记 - 整理
   ![标记-整理](/uploads/java/jvm/标记-整理.jpg)
   让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
   
   ### 3.复制
   ![复制](/uploads/java/jvm/复制.jpg)
   将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。
   
   主要不足是只使用了内存的一半。
   
   现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。
   
   HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。
    
   ### 4.分代收集
   现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。
   
   一般将堆分为新生代和老年代。
   
   - 新生代使用：复制算法
   - 老年代使用：标记 - 清除 或者 标记 - 整理 算法
    
    
## 垃圾收集器

   ### HotSpot垃圾收集器
   ![HotSpot垃圾收集器](/uploads/java/jvm/HotSpot垃圾收集器.jpg)
   
   连线表示可以配合使用。
   
   - 单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；
   - 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 
    
   ### 1.Serial 收集器
   串行，单线程。优点：高效，单cpu环境没有线程交互的切换，拥有最高的单线程收集效率。
   
   **client模式的下的默认新生代**垃圾收集器。因为在该应用场景下，分配给虚拟机管理的内存一般来说不会很大。
   
   Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。

   ### 2.ParNew 收集器
   Serial 收集器的多线程版本。
   
   是 **Server 模式下的虚拟机首选新生代**收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。
   
   默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。
   
   ### 3.Parallel Scavenge 收集器
   多线程收集器。
  
   其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。
  
   停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。
   
   缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。
   
   可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。
   
   ### 4.Serial Old 收集器
   是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：
   
   - 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
   - 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。
   
   ### 5.Parallel Old 收集器
   是 Parallel Scavenge 收集器的老年代版本。
   
   在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

   ### 6. CMS 收集器
   ![CMS收集器](/uploads/java/jvm/CMS收集器.jpg)
   CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。
   
   分为以下四个流程：
   
   - 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
   - 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
   - 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
   - 并发清除：不需要停顿。
   
   在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。
   
   具有以下缺点：
   
   - 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
   - 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
   - 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。
   
   ### 7. G1 收集器
   ![CMS收集器](/uploads/java/jvm/CMS收集器.jpg)
   G1（Garbage-First），它是一款面向**服务端应用**的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。
      
   堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。
   
   ![HotspotHeapStructure](/uploads/java/jvm/HotspotHeapStructure.png)
   G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。         
   
   ![G1HeapAllocation](/uploads/java/jvm/G1HeapAllocation.png)
   
   通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。
   
   每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。
   
   ![G1收集器](/uploads/java/jvm/G1收集器.jpg)   
   
   如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：
   
   - 初始标记
   - 并发标记
   - 重新标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
   - 并发清除：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。
      
   具备如下特点：
      
   - 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
   - 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。Full GC。
       
# 四：内存分配与回收策略

## Minor GC 和 Full GC
   - Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
   - Full GC：发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

## 内存分配策略

   ### 1.对象优先在Eden分配
   大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。
   
   ### 2.大对象直接进入老年代
   大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
   
   经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
   
   -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。
   
   ### 3.长期存活的对象进入老年代
   为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
   
   -XX:MaxTenuringThreshold 用来定义年龄的阈值。
   
   ### 4.动态对象年龄判定
   虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。
   
   ### 5.空间分配担保
   在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
   
   如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。

## Full GC 的触发条件
   对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： 
    
   ##### 1.调用 System.gc()
   只是建议虚拟机执行 Full GC，**但是虚拟机不一定真正去执行**。不建议使用这种方式，而是让虚拟机管理内存。
   
   ### 2.老年代空间不足
   老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。
   
   为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数**调大新生代的大小**，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold **调大对象进入老年代的年龄**，让对象在新生代多存活一段时间。
   
   ### 3.空间分配担保失败
   使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。   
   
   ####4.JDK 1.7 及以前的永久代空间不足
   在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。
   
   当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。
   
   为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。
   
   ### 5.Concurrent Mode Failure
   执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

# 五：类加载机制

类是在运行期间第一次使用时动态加载的，而不是编译时期一次性加载。因为如果在编译时期一次性加载，那么会占用很多的内存。

## 类的生命周期

![类生命周期](/uploads/java/jvm/类生命周期.jpg)   

## 类加载过程
    
   ####加载
   查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情： 
   - 通过一个类的全限定名来获取其定义的二进制字节流。
   - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
   - 在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。
    
   相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
   
   加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

   ### 验证：确保被加载的类的正确性
   验证是连接阶段的第一步，目的是保证加载的类符合当前虚拟机的要求。验证阶段大致分四步：
   - 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
   - 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。
   - 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
   - 符号引用验证：确保解析动作能正确执行。
   
   验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
   
   ### 准备：为**类的静态变量**分配内存，初始化默认值 类型默认值 不是程序赋值
   准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
   - 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
   - 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
   - 如果类字段的字段属性表中存在 ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。
   
   ### 解析：把类中的符号引用转换为直接引用
   解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。
   
   直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
   
   ### 初始化 <clinit>
   初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：
   - 声明类变量是指定初始值
   - 使用静态代码块为类变量指定初始值
   
   初始化步骤：
   - 假如这个类还没有被加载和连接，则程序先加载并连接该类
   - 假如该类的直接父类还没有被初始化，则先初始化其直接父类
   - 假如类中有初始化语句，则系统依次执行这些初始化语句
   
   类初始化时机（主动，被动）
   
   只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：
   - 创建类的实例，也就是new的方式 
   - 反射（如 Class.forName(“com.Test”)
   - 访问某个类或接口的静态变量，或者对该静态变量赋值
   - 调用类的静态方法
   - 初始化某个类的子类，则其父类也会被初始化
   - Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类
   
   被动引用的常见例子包括：
   - 通过子类引用父类的静态字段，不会导致子类初始化。 
   > System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义
   - 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。
   > SuperClass[] sca = new SuperClass[10];
   - 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
   > System.out.println(ConstClass.HELLOWORLD);
   
   ### 结束生命周期
   - 执行了System.exit()方法
   - 程序正常执行结束
   - 程序在执行过程中遇到了异常或错误而异常终止
   - 由于操作系统出现错误而导致Java虚拟机进程终止
   
## 类加载器

## 类加载机制
