<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Marcher</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Marcher">
<meta property="og:url" content="https://marchnineteen.github.io/page/2/index.html">
<meta property="og:site_name" content="Marcher">
<meta property="article:author" content="Marcher">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Marcher" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Marcher</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://marchnineteen.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-tool/maven-dependence" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/05/30/tool/maven-dependence/" class="article-date">
  <time datetime="2019-05-30T00:00:00.000Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/tool/">tool</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/05/30/tool/maven-dependence/">maven-dependence</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="scope参数在dependence中表示依赖的范围。"><a href="#scope参数在dependence中表示依赖的范围。" class="headerlink" title="scope参数在dependence中表示依赖的范围。"></a>scope参数在dependence中表示依赖的范围。</h1><p>首先需要知道，maven在编译项目主代码的时候需要使用一套classpath。例如在编译项目主代码的时候需要用到spring-core，该文件以依赖的方式被引入到classpath中。<br>其次，maven在编译和执行测试的时候会使用另一套classpath，Junit就是一个很好的例子，该文件也以依赖的方式引入到测试使用的classpath中，不同的是这里的依赖<br>范围是test。最后，实际运行maven项目的时候，又会使用一套classpath。</p>
<p>依赖范围就是用来控制依赖与这三种classpath（编辑classpath、测试classpath、运行classpath）的关系，maven有以下几种依赖范围：</p>
<p><strong>Compile</strong>：编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的maven依赖，对于<strong>编译、测试、运行</strong>三种classpath都有效。<br>典型的例子是spring-core，在编译、测试和运行的时候都需要使用该依赖。</p>
<p><strong>Test</strong>：测试依赖范围。使用此依赖范围的maven依赖，只对于<strong>测试</strong>的classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子是Junit，<br>它只有在编辑测试代码及运行测试的时候才需要。</p>
<p><strong>Provided</strong>：已提供依赖范围。使用此依赖范围的maven依赖，对于<strong>编译</strong>和<strong>测试</strong>classpath有效，但在运行时无效。典型的例子是servlet-api，<br>编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要maven重复的引入一遍。</p>
<p><strong>Runtime</strong>：运行时依赖范围。使用该依赖范围的maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译<br>只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述的具体JDBC驱动。</p>
<p><strong>System</strong>：系统依赖范围。该依赖与三种classpath的关系，<strong>和Provided依赖范围完全一致</strong>。但是，使用System范围的依赖是必须通过systemPath元素显示地指定<br>依赖文件的路径。由于此类依赖不是通过maven仓库解析的，而且往往与本机的系统绑定，可能造成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境<br>变量，如：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;java.sql&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
    &lt;scope&gt;system&lt;/scope&gt;
    &lt;systemPath&gt;${java.home}/lib/rt.jar&lt;/systemPath&gt;
&lt;/dependency&gt;</code></pre><p><strong>Import(maven2.0.9及以上)</strong>：导入依赖范围。该依赖范围不会对3中classpath产生实际影响。    </p>
<p>上述出import依赖的各种依赖范围3中classpath的关系如下表：</p>
<table>
<thead>
<tr>
<th align="center">依赖范围(scope)</th>
<th align="left">编译classpath有效</th>
<th align="left">测试classpath有效</th>
<th align="left">运行classpath有效</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">compile</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">spring-core</td>
</tr>
<tr>
<td align="center">test</td>
<td align="left">-</td>
<td align="left">Y</td>
<td align="left">-</td>
<td align="left">junit</td>
</tr>
<tr>
<td align="center">provided</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">-</td>
<td align="left">servlet-api</td>
</tr>
<tr>
<td align="center">runtime</td>
<td align="left">-</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">JDBC驱动</td>
</tr>
<tr>
<td align="center">system</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">-</td>
<td align="left">本地的，maven仓库之外的类库文件</td>
</tr>
</tbody></table>
<h1 id="maven传递性依赖"><a href="#maven传递性依赖" class="headerlink" title="maven传递性依赖"></a>maven传递性依赖</h1><p>传递性依赖和依赖范围：</p>
<p>依赖范围不仅可以控制依赖与三种classpath的关系，还对传递性依赖产生影响。例，account-email对于spring-core的依赖范围是compile，spring-core对于commons-logging<br>的依赖范围的是compile，那么account-email对于commons-logging这一传递依赖的范围也及时compile。假设A依赖与B，B依赖与C，我们说A对于B的依赖是第一直接依赖，<br>B对于C的依赖为第二直接依赖，A对于C是传递性依赖。第一直接依赖的范围是和第二直接依赖的范围决定了传递性依赖的范围，如下表所示，最左边一行表示第一直接依赖范围，<br>最上面一行便是第二直接依赖范围，中间的交叉单元格则便是传递性依赖范围:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">compile</th>
<th align="left">test</th>
<th align="left">provided</th>
<th align="left">runtime</th>
</tr>
</thead>
<tbody><tr>
<td align="center">compile</td>
<td align="left">compile</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">runtime</td>
</tr>
<tr>
<td align="center">test</td>
<td align="left">test</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">test</td>
</tr>
<tr>
<td align="center">provided</td>
<td align="left">provided</td>
<td align="left">-</td>
<td align="left">provided</td>
<td align="left">provided</td>
</tr>
<tr>
<td align="center">runtime</td>
<td align="left">runtime</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">runtime</td>
</tr>
</tbody></table>
<p>仔细观察表格，可以发现规律：当第二直接依赖为compile的时候，传递性依赖的范围与第一直接依赖范围一致；当第二直接依赖范围是test的时候，依赖不会得以传递，<br>当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，且传递性依赖的范围同样为provided；当第二传递依赖是runtime的时候，<br>传递性依赖的范围与第一直接依赖的范围一致，丹compile例外，此时传递性依赖的范围为runtime。</p>
<h2 id="maven可选依赖"><a href="#maven可选依赖" class="headerlink" title="maven可选依赖"></a>maven可选依赖</h2><p>使用<optional>元素表示依赖为可选依赖，只会对当前项目产生影响，当其他项目依赖当前项目时，该依赖不会被传递</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2019/05/30/tool/maven-dependence/" data-id="ckam2zs1h0016meq3cexoe5dl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-database/sqlOptimization" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/04/12/database/sqlOptimization/" class="article-date">
  <time datetime="2019-04-12T00:00:00.000Z" itemprop="datePublished">2019-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/database/">database</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/04/12/database/sqlOptimization/">sql优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SQLOptimizationTree-SQL优化技术"><a href="#SQLOptimizationTree-SQL优化技术" class="headerlink" title="SQLOptimizationTree SQL优化技术"></a>SQLOptimizationTree SQL优化技术</h1><p><img src="https://i.imgur.com/tPBlMI3.png" alt=""></p>
<pre>
1) 最左前缀法则
2）在索引列上做类型转换，函数变换等操作
3）存储引擎不能使用范围条件右边的列作为索引
5）!= , > , <不能使用索引
6）B-tree索引 is null不会走,is not null会走,位图索引 is null,is not null 都会走
7）like 通配符开头不能使用索引
8）尽量使用覆盖索引（只查询索引的列（索引列和查询列一致）），减少select *
9）没有使用查询条件，或者查询条件上没有建立索引
10）查询的数量是索引的大部分，30%以上
11）对小表查询
12）其他存储引擎认为使用索引反而查询性能更差时
13）in, not in ,not exist
15）在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用
16）在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索
引在加快ORDER BY操作方面也没什么作用
17）如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0/1”或“Y/N”等值，就没有
必要为它创建一个索引
18）如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
19）如果mysql估计使用全表扫描要比使用索引快,则不使用索引
20）尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以
    使用 union来查询
21)如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变
   量，但优化程序不能将访问计划的选择到运行时；它必须在编译时进行选择。然而，如果在编译时
   简历访问计划，变量的值还是未知的，因而无法作为索引选择的输入项
22)应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描
23)很多时候用 exists 代替 in 是一个好的选择
25)并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重
   复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即
   使在sex上建了索引也对查询效率起不了作用。
26)尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性
   能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而
   对于数字型而言只需要比较一次就够了
27)尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以
   节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些
28)避免频繁创建和删除临时表，以减少系统表资源的消耗
29)尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写
30)尽量避免大事务操作，提高系统并发能力
</pre>

<p>为排序使用索引</p>
<p><img src="https://i.imgur.com/msPgvCY.png" alt=""></p>
<p><a href="https://blog.csdn.net/tuesdayma/article/details/81783199" target="_blank" rel="noopener">https://blog.csdn.net/tuesdayma/article/details/81783199</a></p>
<pre>
一条sql执行时间过长，如何优化，从哪些方面

1）查看sql是否涉及多表的联表查询或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者
   合并成零时表。
2）涉及联表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合。
3）如果以上两种情况都不能操作，非要联表查询，那么考虑对相应的查询条件做索引，加快查询速度。
5）针对数量大的表进行历史表分离
6）数据库主从分离，读写分离，降低读写针对同一表时的压力
7）explain分析SQL语句，查看执行计划，分析索引是否用得上，分析扫描行数。
8）查看Mysql执行日志，看看是否有其他方面的问题。
</pre>

<pre>
Mysql深度分页

      一般刚开始学SQL的时候，会这样写 
         SELECT * FROM table ORDER BY id LIMIT 1000, 10; 
      但在数据达到百万级的时候，这样写会慢死 
         SELECT * FROM table ORDER BY id LIMIT 1000000, 10; 
      也许耗费几十秒

      网上很多优化的方法是这样的 
         SELECT * FROM table WHERE id >= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10; 
      是的，速度提升到0.x秒了，看样子还行了
      可是，还不是完美的！

      以下这句才是完美的！ 
          SELECT * FROM table WHERE id BETWEEN 1000000 AND 1000010; 
      比上面那句，还要再快5至10倍


      从中我们也能总结出两件事情：
         1）limit语句的查询时间与起始记录的位置成正比
         2）mysql的limit语句是很方便，但是对记录很多的表并不适合直接使用。

      2.对limit分页问题的性能优化方法
        利用表的覆盖索引来加速分页查询
        我们都知道，利用了索引查询的语句中如果只包含了那个索引列（覆盖索引），那么这种情况会查询很快。
        因为利用索引查找有优化算法，且数据就在查询索引上面，不用再去找相关的数据地址了，这样节省了很多时间。另外Mysql中
        也有相关的索引缓存，在并发高的时候利用缓存就效果更好了。


      另外，如果需要查询 id 不是连续的一段，最佳的方法就是先找出 id ，然后用 in 查询 
           SELECT * FROM table WHERE id IN(10000, 100000, 1000000...); 
      再分享一点
      查询字段一较长字符串的时候，表设计时要为该字段多加一个字段,如，存储网址的字段
          查询的时候，不要直接查询字符串，效率低下，应该查诡该字串的crc32或md5。


      在我们的例子中，我们知道id字段是主键，自然就包含了默认的主键索引。现在让我们看看利用覆盖索引的查询效果如何：
      这次我们之间查询最后一页的数据（利用覆盖索引，只包含id列），如下：
         select id from order limit 800000, 20 0.2秒
         相对于查询了所有列的37.44秒，提升了大概100多倍的速度

      那么如果我们也要查询所有列，有两种方法，一种是id>=的形式，另一种就是利用join，看下实际情况：
         SELECT * FROM order WHERE ID > =(select id from order limit 800000, 1) limit 20
      查询时间为0.2秒，简直是一个质的飞跃啊，哈哈

      另一种写法
         SELECT * FROM order a JOIN (select id from order limit 800000, 20) b ON a.ID = b.id
      查询时间也很短
</pre>

<pre>
查询锁表信息
      当前运行的所有事务
      select * from information_schema.innodb_trx
      当前出现的锁
      select * from information_schema.innodb_locks
      锁等待的对应关系
      select * from information_schema.innodb_lock_waits  
</pre>

<pre>
Mysql一次插入几万条数据处理方式

      1）Insert批量插入，调整max_allowed_packet
      2) 开启事务，增大innodb_log_buffer_size，增加单事务提交日志量。
      3）主键顺序插入，效率更高
      5）对要插入的数据进行分组批量插入

      INSERT INTO table (column1, column2, ..., column_n) VALUES 
      (value11, value12, ..., value1n), 
      (value21, value22, ... value2n), ..., (value_n1, value_n2, ... value_nn)


      常用的插入语句如：
      INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
             VALUES ('0', 'userid_0', 'content_0', 0);
      INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
             VALUES ('1', 'userid_1', 'content_1', 1);
      修改成：


      INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
      VALUES ('0', 'userid_0', 'content_0', 0), ('1', 'userid_1', 'content_1', 1);

      修改后的插入操作能够提高程序的插入效率。这里第二种SQL执行效率高的主要原因是合并后日志量（MySQL的binlog和innodb的事务让
      日志）减少了，降低日志刷盘的数据量和频率，从而提高效率。通过合并SQL语句，同时也能减少SQL语句解析的次数，减少网络传
      输的IO。


      数据有序插入。
          数据有序的插入是指插入记录在主键上是有序排列，例如datetime是记录的主键：
          INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
                 VALUES ('1', 'userid_1', 'content_1', 1);
          INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
                 VALUES ('0', 'userid_0', 'content_0', 0);
          INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
                 VALUES ('2', 'userid_2', 'content_2',2);
          修改成：

          INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
                 VALUES ('0', 'userid_0', 'content_0', 0);
          INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
                 VALUES ('1', 'userid_1', 'content_1', 1);
          INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
                 VALUES ('2', 'userid_2', 'content_2',2);
          由于数据库插入时，需要维护索引数据，无序的记录会增大维护索引的成本。我们可以参照InnoDB使用的B+tree索引，如果每次插
          入记录都在索引的最后面，索引的定位效率很高，并且对索引调整较小；如果插入的记录在索引中间，需要B+tree进行分裂合并等
          处理，会消耗比较多计算资源，并且插入记录的索引定位效率会下降，数据量较大时会有频繁的磁盘操作。


      从测试结果来看，该优化方法的性能有所提高，但是提高并不是很明显。

      SQL语句是有长度限制，在进行数据合并在同一SQL中务必不能超过SQL长度限制，通过max_allowed_packet配置可以修改，默认是1M，
      测试时修改为8M。

      事务需要控制大小，事务太大可能会影响执行的效率。MySQL有innodb_log_buffer_size配置项，超过这个值会把innodb的数据刷到
      磁盘中，这时，效率会有所下降。所以比较好的做法是，在数据达到这个这个值前进行事务提交。
</pre>

<pre>
Mysql配置优化提高SQL查询写入性能

      提高数据库插入性能的中心思想：
              1）尽量将数据一次性写入到Data File
              2）减少数据库的checkpoint 操作

      innodb_buffer_pool_size 
           如果用Innodb，那么这是一个重要变量。相对于MyISAM来说，Innodb对于
        buffer size更敏感。MySIAM可能对于大数据量使用默认的key_buffer_size也还好，
        但Innodb在大数据量时用默认值就感觉在爬了。 Innodb的缓冲池会缓存数据和索引，所
        以不需要给系统的缓存留空间，如果只用Innodb，可以把这个值设为内存的70%-80%。
        和 key_buffer相同，如果数据量比较小也不怎么增加，那么不要把这个值设太高也可以提
        高内存的使用率。

      innodb_log_file_size 
           此配置项作用设定innodb 数据库引擎UNDO日志的大小；从而减少数据库checkpoint
        操作。

           对于写很多尤其是大数据量时非常重要。要注意，大的文件提供更高的性能，但数据库恢
        复时会用更多的时间。我一般用64M-512M，具体取决于服务器的空间。

      innodb_log_buffer_size 
           此配置项作用设定innodb 数据库引擎写日志缓存区；将此缓存段增大可以减少数据库写
        数据文件次数

           默认值对于多数中等写操作和事务短的运用都是可以的。如 果经常做更新或者使用了
        很多blob数据，应该增大这个值。但太大了也是浪费内存，因为1秒钟总会 flush（这个词
        的中文怎么说呢？）一次，所以不需要设到超过1秒的需求。8M-16M一般应该够了。小的运用
        可以设更小一点。

      innodb_flush_log_at_trx_commit 
           0: Write the log buffer to the log file and flush the log file 
              every second, but do nothing at transaction commit. 
           1：the log buffer is written out to the log file at each 
              transaction commit and the flush to disk operation is performed 
              on the log file 
           2：the log buffer is written out to the file at each commit, but 
              the flush to disk operation is not performed on it 

           抱怨Innodb比MyISAM慢 100倍？那么你大概是忘了调整这个值。默认值1的意思是每一
        次事务提交或事务外的指令都需要把日志写入（flush）硬盘，这是很费时的。特别是使用
        电 池供电缓存（Battery backed up cache）时。设成2对于很多运用，特别是从MyISAM
        表转过来的是可以的，它的意思是不写入硬盘而是写入系统缓存。日志仍然会每秒flush到
        硬 盘，所以你一般不会丢失超过1-2秒的更新。设成0会更快一点，但安全方面比较差，即
        使MySQL挂了也可能会丢失事务的数据。而值2只会在整个操作系统 挂了时才可能丢数据。

      innodb_autoextend_increment 配置由于默认8M 调整到 128M
           此配置项作用主要是当tablespace 空间已经满了后，需要MySQL系统需要自动扩展多
        少空间，每次tablespace 扩展都会让各个SQL 处于等待状态。增加自动扩展Size可以减
        少tablespace自动扩展次数。

      提高数据库插入性能中心思想： 
          1、尽量使数据库一次性写入Data File 
          2、减少数据库的checkpoint 操作 
          3、程序上尽量缓冲数据，进行批量式插入与提交 
          4、减少系统的IO冲突

      提高数据库读取速度
</pre>

<pre>
Mysql表查询优化经验
</pre>

<pre>
Using index 
      查询的列被索引覆盖，并且where筛选条件是索引的是前导列

      Using where Using index
        1:查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的不是前导列，
          Extra中为Using where; Using index，意味着无法直接通过索引查找来查询到符
          合条件的数据
        2:查询的列被索引覆盖，并且where筛选条件是索引列前导列的一个范围，同样意味着无法
          直接通过索引查找查询到符合条件的数据
     NULL（既没有Using index，也没有Using where Using index，也没有using where）
        1，查询的列未被索引覆盖，并且where筛选条件是索引的前导列，
　　     意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用
         到了索引，也不是完全没用到索引，Extra中为NULL(没有信息)
     Using where
        1，查询的列未被索引覆盖，where筛选条件非索引的前导列，Extra中为Using where
        2，查询的列未被索引覆盖，where筛选条件非索引列，Extra中为Using where

        using where 意味着通过索引或者表扫描的方式进程where条件的过滤，
　　    反过来说，也就是没有可用的索引查找，当然这里也要考虑索引扫描+回表与表扫描的代价。
　　    这里的type都是all，说明MySQL认为全表扫描是一种比较低的代价。
     Using index condition
        1，-- 查询的列不全在索引中，where条件中是一个前导列的范围
        2，查询列不完全被索引覆盖，查询条件完全可以使用到索引（进行索引查找）
</pre>

<p><img src="https://i.imgur.com/UCgL2Vh.png" alt=""></p>
<pre>
Explain详细解析

      table：表名
      type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、
            eq_reg、ref、range、index和ALL
      possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关
            的域从WHERE语句中选择一个合适的语句
      key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足
            的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使
            用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引
      key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好
      ref：显示索引的哪一列被使用了，如果可能的话，是一个常数
      rows：MYSQL认为必须检查的用来返回请求数据的行数

      extra列返回的描述的意义
           Distinct:一旦MYSQL找到了与行相联合匹配的行，就不再搜索了

           Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不
                       再搜索了

           Range checked for each Record（index map:#）:没有找到理想的索引，因此对
               于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中
               返回行。这是使用索引的最慢的连接之一

           Using filesort: 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来
               发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行
               的行指针来排序全部行

           Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返
                        回的，这发生在对表的全部的请求列都是同一个索引的部分的时候

           Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时
                 表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上

           Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果
                不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有
                问题不同连接类型的解释（按照效率高低的顺序排序）

           system 表只有一行：system表。这是const连接类型的特殊情况

           const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因
              为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待

           eq_ref:在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取
                  一个记录，它在查询使用了索引为主键或惟一键的全部时使用

           ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分
             （比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从
              表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好

           range:这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西时发生的情况

           index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为
                 索引一般小于表数据）

           ALL:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免
</pre>

<pre>
子查询 联合join查询效率
</pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2019/04/12/database/sqlOptimization/" data-id="ckam2zs0k000bmeq3cl8m99sz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-database/数据库系统原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/04/12/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2019-04-12T00:00:00.000Z" itemprop="datePublished">2019-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/database/">database</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/04/12/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">数据库系统原理(转载)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md" target="_blank" rel="noopener">原文</a></p>
<ul>
<li><a href="#一事务">一、事务</a><ul>
<li><a href="#概念">概念</a></li>
<li><a href="#acid">ACID</a></li>
<li><a href="#autocommit">AUTOCOMMIT</a></li>
</ul>
</li>
<li><a href="#二并发一致性问题">二、并发一致性问题</a><ul>
<li><a href="#丢失修改">丢失修改</a></li>
<li><a href="#读脏数据">读脏数据</a></li>
<li><a href="#不可重复读">不可重复读</a></li>
<li><a href="#幻影读">幻影读</a></li>
</ul>
</li>
<li><a href="#三封锁">三、封锁</a><ul>
<li><a href="#封锁粒度">封锁粒度</a></li>
<li><a href="#封锁类型">封锁类型</a></li>
<li><a href="#封锁协议">封锁协议</a></li>
<li><a href="#mysql-隐式与显示锁定">MySQL 隐式与显示锁定</a></li>
</ul>
</li>
<li><a href="#四隔离级别">四、隔离级别</a><ul>
<li><a href="#未提交读read-uncommitted">未提交读（READ UNCOMMITTED）</a></li>
<li><a href="#提交读read-committed">提交读（READ COMMITTED）</a></li>
<li><a href="#可重复读repeatable-read">可重复读（REPEATABLE READ）</a></li>
<li><a href="#可串行化serializable">可串行化（SERIALIZABLE）</a></li>
</ul>
</li>
<li><a href="#五多版本并发控制">五、多版本并发控制</a><ul>
<li><a href="#版本号">版本号</a></li>
<li><a href="#隐藏的列">隐藏的列</a></li>
<li><a href="#undo-日志">Undo 日志</a></li>
<li><a href="#实现过程">实现过程</a></li>
<li><a href="#快照读与当前读">快照读与当前读</a></li>
</ul>
</li>
<li><a href="#六next-key-locks">六、Next-Key Locks</a><ul>
<li><a href="#record-locks">Record Locks</a></li>
<li><a href="#gap-locks">Gap Locks</a></li>
<li><a href="#next-key-locks">Next-Key Locks</a></li>
</ul>
</li>
<li><a href="#七关系数据库设计理论">七、关系数据库设计理论</a><ul>
<li><a href="#函数依赖">函数依赖</a></li>
<li><a href="#异常">异常</a></li>
<li><a href="#范式">范式</a></li>
</ul>
</li>
<li><a href="#八er-图">八、ER 图</a><ul>
<li><a href="#实体的三种联系">实体的三种联系</a></li>
<li><a href="#表示出现多次的关系">表示出现多次的关系</a></li>
<li><a href="#联系的多向性">联系的多向性</a></li>
<li><a href="#表示子类">表示子类</a></li>
</ul>
</li>
<li><a href="#参考资料">参考资料</a><!-- GFM-TOC -->


</li>
</ul>
<h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/f74144be-857a-40cd-8ec7-87626ef4e20b.png"/> </div><br>

<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>使用重做日志来保证持久性。</p>
<hr>
<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对数据库崩溃的情况。</li>
</ul>
<div align="center"> <img src="https://github.com//CyC2018/CS-Notes/raw/master/notes/pics/417bc315-4409-48c6-83e0-59e8d405429e.jpg" width="700"/> </div><br>

<h2 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p>
<h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><p>T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/75184b58-c627-4edc-8dcf-605762ebb733.png" width="350"/> </div><br>

<h2 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h2><p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/af0e94d9-502d-4531-938f-d46dd29de52d.png" width="400"/> </div><br>

<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/66ae164c-ad47-4905-895e-51fe38ce797a.png" width="400"/> </div><br>


<h2 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h2><p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/8fdc577d-552d-4b43-b5e4-a8f98bc2cb51.png" width="400"/> </div><br>


<hr>
<p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/1a851e90-0d5c-4d4f-ac54-34c20ecfb903.jpg" width="300"/> </div><br>

<h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><h3 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1. 读写锁"></a>1. 读写锁</h3><ul>
<li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<p>锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">X</th>
<th align="center">S</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h3 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2. 意向锁"></a>2. 意向锁</h3><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">X</th>
<th align="center">IX</th>
<th align="center">S</th>
<th align="center">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">IS</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li>
<li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li>
</ul>
<h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1. 三级封锁协议"></a>1. 三级封锁协议</h3><p><strong>一级封锁协议</strong> </p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<table>
<thead>
<tr>
<th align="center">T<sub>1</sub></th>
<th align="center">T<sub>2</sub></th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock-x(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">read A=20</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">lock-x(A)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">wait</td>
</tr>
<tr>
<td align="center">write A=19</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center">unlock-x(A)</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">obtain</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">read A=19</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">write A=21</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">commit</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">unlock-x(A)</td>
</tr>
</tbody></table>
<p><strong>二级封锁协议</strong> </p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<table>
<thead>
<tr>
<th align="center">T<sub>1</sub></th>
<th align="center">T<sub>2</sub></th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock-x(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">read A=20</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">write A=19</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">lock-s(A)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">wait</td>
</tr>
<tr>
<td align="center">rollback</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center">A=20</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center">unlock-x(A)</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">obtain</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">read A=20</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">unlock-s(A)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">commit</td>
</tr>
</tbody></table>
<p><strong>三级封锁协议</strong> </p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<table>
<thead>
<tr>
<th align="center">T<sub>1</sub></th>
<th align="center">T<sub>2</sub></th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock-s(A)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">read A=20</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">lock-x(A)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">wait</td>
</tr>
<tr>
<td align="center">read A=20</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center">unlock-s(A)</td>
<td align="center">.</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">obtain</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">read A=20</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">write A=19</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">commit</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">unlock-X(A)</td>
</tr>
</tbody></table>
<h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>

<p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>

<h2 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><h2 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h2><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h2 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h2><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h2 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h2><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p>
<h2 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h2><p>强制事务串行执行。</p>
<hr>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻影读</th>
<th align="center">加锁读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">提交读</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">可串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ul>
<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号：事务开始时的系统版本号。</li>
</ul>
<h2 id="隐藏的列"><a href="#隐藏的列" class="headerlink" title="隐藏的列"></a>隐藏的列</h2><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p>
<ul>
<li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li>
<li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li>
</ul>
<h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/e41405a8-7c05-4f70-8092-e961e28d3112.jpg" width=""/> </div><br>

<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>以下实现过程针对可重复读隔离级别。</p>
<p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p>
<h3 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1. SELECT"></a>1. SELECT</h3><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p>
<p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p>
<h3 id="2-INSERT"><a href="#2-INSERT" class="headerlink" title="2. INSERT"></a>2. INSERT</h3><p>将当前系统版本号作为数据行快照的创建版本号。</p>
<h3 id="3-DELETE"><a href="#3-DELETE" class="headerlink" title="3. DELETE"></a>3. DELETE</h3><p>将当前系统版本号作为数据行快照的删除版本号。</p>
<h3 id="4-UPDATE"><a href="#4-UPDATE" class="headerlink" title="4. UPDATE"></a>4. UPDATE</h3><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p>
<h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><h3 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h3><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure>

<h3 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h3><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line"><span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<h2 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h2><p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h2 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h2><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure>

<h1 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
<th align="center">Mname</th>
<th align="center">Cname</th>
<th align="center">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
<td align="center">课程-1</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-1</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">95</td>
</tr>
</tbody></table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/c2d343f7-604c-4856-9a3c-c71d6f67fecc.png" width="300"/> </div><br>

<h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>属性不可分。</p>
<h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><font size=4> <strong>分解前</strong> </font><br></p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
<th align="center">Mname</th>
<th align="center">Cname</th>
<th align="center">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
<td align="center">课程-1</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-1</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">95</td>
</tr>
</tbody></table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><font size=4> <strong>分解后</strong> </font><br></p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
<th align="center">Mname</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Cname</th>
<th align="center">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">课程-1</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">课程-2</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">课程-1</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">课程-2</td>
<td align="center">95</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt;  Grade</li>
</ul>
<h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递函数依赖：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
</tr>
</tbody></table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th align="center">Sdept</th>
<th align="center">Mname</th>
</tr>
</thead>
<tbody><tr>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
</tr>
<tr>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
</tr>
</tbody></table>
<h1 id="八、ER-图"><a href="#八、ER-图" class="headerlink" title="八、ER 图"></a>八、ER 图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h2 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h2><p>包含一对一，一对多，多对多三种。</p>
<ul>
<li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li>
<li>如果是一对一，画两个带箭头的线段；</li>
<li>如果是多对多，画两个不带箭头的线段。</li>
</ul>
<p>下图的 Course 和 Student 是一对多的关系。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/pics/292b4a35-4507-4256-84ff-c218f108ee31.jpg" width=""/> </div><br>

<h2 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。</p>
<p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/8b798007-e0fb-420c-b981-ead215692417.jpg" width=""/> </div><br>

<h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/423f2a40-bee1-488e-b460-8e76c48ee560.png" width=""/> </div><br>

<p>一般只使用二元联系，可以把多元联系转换为二元联系。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/de9b9ea0-1327-4865-93e5-6f805c48bc9e.png" width=""/> </div><br>

<h2 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>
<div align="center"> <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/7ec9d619-fa60-4a2b-95aa-bf1a62aad408.jpg" width=""/> </div><br>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.</li>
<li>施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.</li>
<li>史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">The InnoDB Storage Engine</a></li>
<li><a href="https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels" target="_blank" rel="noopener">Transaction isolation levels</a></li>
<li><a href="http://scanftree.com/dbms/2-phase-locking-protocol" target="_blank" rel="noopener">Concurrency Control</a></li>
<li><a href="https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666" target="_blank" rel="noopener">The Nightmare of Locking, Blocking and Isolation Levels!</a></li>
<li><a href="https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html" target="_blank" rel="noopener">Database Normalization and Normal Forms with an Example</a></li>
<li><a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/" target="_blank" rel="noopener">The basics of the InnoDB undo logging and history system</a></li>
<li><a href="https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/" target="_blank" rel="noopener">MySQL locking for the busy web developer</a></li>
<li><a href="https://draveness.me/mysql-innodb" target="_blank" rel="noopener">浅入浅出 MySQL 和 InnoDB</a></li>
<li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb 中的事务隔离级别和锁的关系</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2019/04/12/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" data-id="ckam2zs0m000dmeq3fxfeaakk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/javase/thread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/03/02/java/javase/thread/" class="article-date">
  <time datetime="2019-03-02T00:00:00.000Z" itemprop="datePublished">2019-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/JavaSE/">JavaSE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/03/02/java/javase/thread/">java线程解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h1><p>并行与并发：</p>
<ul>
<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是<strong>真正的同时</strong>。 </li>
<li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li>
<li>线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果。</li>
<li>同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</li>
<li>volatile：多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。<br>针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。</li>
</ul>
<p><img src="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-thread/src/main/resources/static/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%8E%9F%E5%9E%8B.jpg" alt="多线程内存原型"> </p>
<h1 id="线程状态-amp-状态切换"><a href="#线程状态-amp-状态切换" class="headerlink" title="线程状态&amp;状态切换"></a>线程状态&amp;状态切换</h1><p><img src="http://upload-images.jianshu.io/upload_images/4942449-8f4ad7b6ac7009c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程状态转换"> </p>
<h2 id="对象方法："><a href="#对象方法：" class="headerlink" title="对象方法："></a>对象方法：</h2><ul>
<li>wait()：当前线程放弃对象锁，使该线程处于<strong>等待池</strong>(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到<strong>锁定池</strong>(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）。</li>
<li>notify():从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。</li>
<li>notifyAll(): notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。</li>
</ul>
<p>注意点：<a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-thread/src/main/java/com/wyb/thread/base/synchronize" target="_blank" rel="noopener">源码</a></p>
<ul>
<li><strong>wait()当前线程立即释放对象锁，notify() notifyAll() 之后 才会执行剩下代码</strong></li>
<li><strong>notify() notifyAll() 本身不会释放锁，仅仅是通知，当同步块执行完毕之后才会释放锁</strong>。</li>
</ul>
<h2 id="Thread线程方法："><a href="#Thread线程方法：" class="headerlink" title="Thread线程方法："></a>Thread线程方法：</h2><ul>
<li>yield():正在执行的线程把运行机会交给线程池中拥有相同优先级的线程，无法保证迅速转换，运行状态转到可运行状态.</li>
<li>join():使得一个线程在另一个线程结束后再执行。在一个线程中调用other.join(),将等待other执行完后才继续本线程。</li>
<li>sleep():不会释放对象锁，暂停一段时间。</li>
<li>interrupt()：后两个函数皆可以被打断。</li>
</ul>
<p>使用condition控制线程通信：</p>
<ul>
<li>await(),类似wait()</li>
<li>signal() 类似notify</li>
<li>signalAll()类似notifyAll</li>
</ul>
<h1 id="高级多线程控制类："><a href="#高级多线程控制类：" class="headerlink" title="高级多线程控制类："></a>高级多线程控制类：</h1><h2 id="1-ThreadLocal类"><a href="#1-ThreadLocal类" class="headerlink" title="1.ThreadLocal类:"></a>1.ThreadLocal类:</h2><h2 id="2-原子类（AtomicInteger、AtomicBoolean……）"><a href="#2-原子类（AtomicInteger、AtomicBoolean……）" class="headerlink" title="2.原子类（AtomicInteger、AtomicBoolean……）"></a>2.原子类（AtomicInteger、AtomicBoolean……）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; cas方法</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">&#x2F;&#x2F;使用unsafe的native方法，实现高效的硬件级别CAS</span><br><span class="line">return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Lock类"><a href="#3-Lock类" class="headerlink" title="3.Lock类　"></a>3.Lock类　</h2><ul>
<li>Condition</li>
<li>ReentrantLock</li>
</ul>
<p><img src="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-thread/src/main/resources/static/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E8%8E%B7%E5%8F%96%E9%94%81%E8%BF%87%E7%A8%8B.jpg" alt="非公平锁获取锁过程"></p>
<p>公平锁和非公平锁不同之处在于，公平锁在获取锁的时候，不会先去检查state状态，而是直接执行aqcuire(1),即直接进入队列</p>
<p>so:由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。所以也就能解释非公平锁的效率会被公平锁更高。</p>
<ul>
<li>ReentrantReadWriteLock.ReadLock</li>
<li>ReentrantReadWriteLock.WriteLock</li>
</ul>
<h2 id="4-容器类"><a href="#4-容器类" class="headerlink" title="4.容器类"></a>4.容器类</h2><ul>
<li>BlockingQueue</li>
<li>ConcurrentHashMap</li>
</ul>
<h2 id="5-管理类"><a href="#5-管理类" class="headerlink" title="5.管理类"></a>5.管理类</h2><ul>
<li>ThreadPoolExecutor</li>
</ul>
<p>线程池构成方法参数：</p>
<p>1.指定核心线程数量</p>
<p>2.</p>
<p>队列排队策略：</p>
<p>同步移交：不会放到队列中，而是等待线程执行它。如果当前线程没有执行，很可能会新开一个线程执行。</p>
<p>核心线程满了，接下来进队列，队列也满了，创建新线程，直到达到最大线程数，之后再超出，会进入拒绝rejectedExecution</p>
<ul>
<li>JMX框架下的系统级管理类 ThreadMXBean</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2019/03/02/java/javase/thread/" data-id="ckam2zs2c002emeq35dqvgym2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-design/behavioral/chainOfResponsibility" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/01/24/java/java-design/behavioral/chainOfResponsibility/" class="article-date">
  <time datetime="2019-01-24T00:00:00.000Z" itemprop="datePublished">2019-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/java-design-patterns/">java-design-patterns</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/01/24/java/java-design/behavioral/chainOfResponsibility/">Java设计模式：责任链模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>定义个抽象类，依赖一个本身对象，每个继承类，即可传入其它的继承类实现对象链。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义处理器抽象类 依赖一个本身对象，通过构造器传入，拥有一个处理请求的抽象方法 </p>
<pre><code>protected Handler successor;

    public Handler(Handler successor) {
        this.successor = successor;
    }


    protected abstract void handleRequest(Request request);</code></pre><p>   请求参数类</p>
<pre><code>public class Request {

    private RequestType type;
    private String name;


    public Request(RequestType type, String name) {
        this.type = type;
        this.name = name;
    }


    public RequestType getType() {
        return type;
    }


    public String getName() {
        return name;
    }

}</code></pre><p>   请求类型枚举类 不同的请求类型 调用不同的处理器</p>
<pre><code>public enum RequestType {
    TYPE1, TYPE2, TYPE3
} </code></pre><p>   定义处理器类1继承抽象类处理类型为TYPE1的请求</p>
<pre><code>public class ConcreteHandler1 extends Handler {

   public ConcreteHandler1(Handler successor) {
       super(successor);
   }

   @Override
   protected void handleRequest(Request request) {
       if (RequestType.TYPE1 == request.getType()) {
           System.out.println(request.getName() + &quot; is handle by ConcreteHandler1&quot;);
           return;
       }
       if (successor != null) {
           successor.handleRequest(request);
       }
   }
}</code></pre><p>   定义处理器类2继承抽象类处理类型为TYPE2的请求</p>
<pre><code>public class ConcreteHandler2 extends Handler {
   public ConcreteHandler2(Handler successor) {
       super(successor);
   }

   @Override
   protected void handleRequest(Request request) {
       if (request.getType() == RequestType.TYPE2) {
           System.out.println(request.getName() + &quot; is handle by ConcreteHandler2&quot;);
           return;
       }
       if (successor != null) {
           successor.handleRequest(request);
       }
   }
}</code></pre><p>   测试：</p>
<pre><code>public class Client {

   public static void main(String[] args) {

       Handler handler1 = new ConcreteHandler1(null);
       Handler handler2 = new ConcreteHandler2(handler1);

       Request request1 = new Request(RequestType.TYPE1, &quot;request1&quot;);
       handler2.handleRequest(request1);
       Request request2 = new Request(RequestType.TYPE2, &quot;request2&quot;);
       handler2.handleRequest(request2);

       Handler handler3 = new ConcreteHandler3(handler2);
       Request request3 = new Request(RequestType.TYPE3, &quot;request3&quot;);
       handler3.handleRequest(request1);
   }
}</code></pre><p>   输出：</p>
<pre><code>request1 is handle by ConcreteHandler1
request2 is handle by ConcreteHandler2</code></pre><p>   再定义一个定义处理器类3继承抽象类处理类型为TYPE3的请求</p>
<pre><code>public class ConcreteHandler3 extends Handler {

   public ConcreteHandler3(Handler successor) {
       super(successor);
   }

   @Override
   protected void handleRequest(Request request) {
       if (RequestType.TYPE3 == request.getType()) {
           System.out.println(request.getName() + &quot; is handle by ConcreteHandler3&quot;);
           return;
       }
       if (successor != null) {
           successor.handleRequest(request);
       }
   }
}</code></pre><p>   测试：使用handler3处理request1请求</p>
<pre><code>public class Client {

    public static void main(String[] args) {

        Handler handler1 = new ConcreteHandler1(null);
        Handler handler2 = new ConcreteHandler2(handler1);

        Request request1 = new Request(RequestType.TYPE1, &quot;request1&quot;);
        Handler handler3 = new ConcreteHandler3(handler2);
        Request request3 = new Request(RequestType.TYPE3, &quot;request3&quot;);
        handler3.handleRequest(request1);
    }
}</code></pre><p>   输出：最外层的Handler即调用所有类型的处理请求</p>
<pre><code>request1 is handle by ConcreteHandler1</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2019/01/24/java/java-design/behavioral/chainOfResponsibility/" data-id="ckam2zs2l002pmeq3co12az7e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-design/behavioral/observer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/01/24/java/java-design/behavioral/observer/" class="article-date">
  <time datetime="2019-01-24T00:00:00.000Z" itemprop="datePublished">2019-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/java-design-patterns/">java-design-patterns</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/01/24/java/java-design/behavioral/observer/">Java设计模式：观察者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>主题依赖了观察者的一个集合，观察者依赖了一个主题，生成一个观察者需要在主题进行注册，主题更新后对每个观察者进行推送</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义主题接口，拥有对观察者的操作方法</p>
<pre><code>public interface Subject {

    // 注册观察者
    public void registerObserver(Observer observer);

    // 移除观察者
    public void removeObserver(Observer observer);

    // 提醒观察者
    public void notifyObserver();
}</code></pre><p>   定义一个观察者接口，提供一个操作接口，方便主题更新时对观察者进行操作</p>
<pre><code>public interface Observer {

    void update(float temp, float humidity, float pressure);
}</code></pre><p>   定义主题接口实现类，依赖了一个观察者集合，当对主题进行更新时，循环通知各个观察者</p>
<pre><code>public class WeatherSubject implements Subject {

    private List&lt;Observer&gt; observers;
    private float temperature;
    private float humidity;
    private float pressure;

    public WeatherSubject() {
        observers = new ArrayList&lt;&gt;();
    }

    public void setMeasurements(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        notifyObserver();
    }

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        int i = observers.indexOf(observer);
        if (i &gt;= 0) {
            observers.remove(i);
        }
    }

    @Override
    public void notifyObserver() {
        for (Observer o : observers) {
            o.update(temperature, humidity, pressure);
        }
    }
}</code></pre><p>   定义观察者实现类，每个观察者通过构造方法传入它所订阅的主题，并在主题中注册该观察者</p>
<pre><code>public class StatisticsDisplay implements Observer {

    public StatisticsDisplay(Subject weatherData) {
        weatherData.registerObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println(&quot;StatisticsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);
    }
}</code></pre><p>   定义另一个观察者实现类</p>
<pre><code>public class CurrentConditionsDisplay implements Observer {

    public CurrentConditionsDisplay(Subject weatherData) {
        weatherData.registerObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println(&quot;CurrentConditionsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure);
    }

}</code></pre><p>   测试：</p>
<pre><code>public class Client {

    public static void main(String[] args) {
        WeatherSubject subject = new WeatherSubject();
        Observer statis = new StatisticsDisplay(subject);
        Observer current = new CurrentConditionsDisplay(subject);
        subject.setMeasurements(22f, 29f, 100f);
    }
}</code></pre><p>   输出：</p>
<pre><code>StatisticsDisplay.update: 22.0 29.0 100.0
CurrentConditionsDisplay.update: 22.0 29.0 100.0</code></pre><h2 id="JDK实现"><a href="#JDK实现" class="headerlink" title="JDK实现"></a>JDK实现</h2><p>第一眼看到这个模式就感觉这不就是java的监听器嘛，其实监听器就是通过这种模式实现的。</p>
<ul>
<li>java.util.Observer</li>
<li>java.util.EventListener</li>
<li>javax.servlet.http.HttpSessionBindingListener</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2019/01/24/java/java-design/behavioral/observer/" data-id="ckam2zs2m002qmeq3fgrvf1y2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-design/behavioral/strategy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/01/24/java/java-design/behavioral/strategy/" class="article-date">
  <time datetime="2019-01-24T00:00:00.000Z" itemprop="datePublished">2019-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/java-design-patterns/">java-design-patterns</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/01/24/java/java-design/behavioral/strategy/">Java设计模式：策略模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>定义一系列算法，封装每个算法，并使它们可以互换。策略模式可以让算法独立于使用它的客户端。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>把对象的功能实现定义成一个接口，对象中依赖一个功能接口，通过改变接口的实现，来达到不同的功能。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义功能接口</p>
<pre><code>public interface CallBehavior {

   // 叫，不同动物叫声不同
   void call();
}</code></pre><p>   功能接口实现</p>
<pre><code>public class Quack implements CallBehavior {

    @Override
    public void call() {
        System.out.println(&quot;鸭子叫!&quot;);
    }
}

public class Squeak implements CallBehavior {

   @Override
   public void call() {
       System.out.println(&quot;鸡叫k!&quot;);
   }
}</code></pre><p>   定义对象类，并依赖功能接口，通过改变接口的具体实现达到不同的功能</p>
<pre><code>public class Duck {

    private CallBehavior behavior;

    public void performQuack() {
        if (behavior != null) {
            behavior.call();
        }
    }
    public void setQuackBehavior(CallBehavior behavior) {
        this.behavior = behavior;
    }
}</code></pre><p>   测试：</p>
<pre><code>public class Client {

    public static void main(String[] args) {
        Duck duck = new Duck();
        CallBehavior quack = new Quack();
        duck.setQuackBehavior(quack);
        duck.performQuack();
        CallBehavior squeak = new Squeak();
        duck.setQuackBehavior(squeak);
        duck.performQuack();
    }
}</code></pre><p>   输出：</p>
<pre><code>鸭子叫!
鸡叫k!</code></pre><h2 id="JDK实现"><a href="#JDK实现" class="headerlink" title="JDK实现"></a>JDK实现</h2><ul>
<li>java.util.Comparator#compare()</li>
<li>javax.servlet.http.HttpServlet</li>
<li>javax.servlet.Filter#doFilter()</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2019/01/24/java/java-design/behavioral/strategy/" data-id="ckam2zs2n002smeq3gt6g4f7e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-design/structure/facade" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/01/24/java/java-design/structure/facade/" class="article-date">
  <time datetime="2019-01-24T00:00:00.000Z" itemprop="datePublished">2019-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/java-design-patterns/">java-design-patterns</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/01/24/java/java-design/structure/facade/">Java设计模式：外观模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>定义一个外观对象，在内部进行功能的封装，功能具体是在都在外观类的内部，其它方法要使用该功能<br>调用外观对象的方法即可。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义一个电影播放系统，方法代表需要功能所需步骤</p>
<pre><code>public class SubSystem {

    public void turnOnTV() {
        System.out.println(&quot;turnOnTV()&quot;);
    }

    public void setCD(String cd) {
        System.out.println(&quot;setCD( &quot; + cd + &quot; )&quot;);
    }

    public void starWatching() {
        System.out.println(&quot;starWatching()&quot;);
    }

}</code></pre><p>   定义一个外观类，封装了看电影的三步骤，客户端只需调用外观类的方法即可实现功能</p>
<pre><code>public class Facade {

    private SubSystem subSystem = new SubSystem();

    public void watchMovie(String name) {
        subSystem.turnOnTV();
        subSystem.setCD(name);
        subSystem.starWatching();
    }
}</code></pre><p>   测试：</p>
<pre><code>public class Client {

    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.watchMovie(&quot;家有喜事&quot;);
    }
}</code></pre><p>   测试：</p>
<pre><code>turnOnTV()
setCD( 家有喜事 )
starWatching()</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2019/01/24/java/java-design/structure/facade/" data-id="ckam2zs2w0030meq31fzihowi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-design/structure/flyweight" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/01/24/java/java-design/structure/flyweight/" class="article-date">
  <time datetime="2019-01-24T00:00:00.000Z" itemprop="datePublished">2019-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/java-design-patterns/">java-design-patterns</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/01/24/java/java-design/structure/flyweight/">Java设计模式：享元模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="定义-目的"><a href="#定义-目的" class="headerlink" title="定义(目的)"></a>定义(目的)</h1><p>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>在享元接口中 定义一个方法，即为对象的外部状态，每个对象的外部状态都不同<br>在接口的实现类中添加一个成员变量作为识别标志，在创建工厂类中添加一个Map以识别标志为key，即以对象内部相同状态为key，<br>调用方法即可改变其它状态</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>   定义组享元接口 拥有改变外部对象的方法</p>
<pre><code>public interface Flyweight {

    /**
     * 外部状态，每个享元对象的外部状态不同
     *
     * @param extrinsicState
     */
    public void extrinsicState(String extrinsicState);
}</code></pre><p>   定义一个享元接口实现类，内部状态为成员变量，提供外部状态实现</p>
<pre><code>public class ConcreteFlyweight implements Flyweight {

    private String intrinsicState;

    public ConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }

    @Override
    public void extrinsicState(String extrinsicState) {
        System.out.println(&quot;Object address: &quot; + System.identityHashCode(this));
        System.out.println(&quot;IntrinsicState: &quot; + intrinsicState);
        System.out.println(&quot;ExtrinsicState: &quot; + extrinsicState);
    }
}</code></pre><p>   定义享元对象工厂类，定义一个全局变量map存储享元对象。</p>
<pre><code>public class FlyweightFactory {

    private HashMap&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;();

    public Flyweight getFlyweight(String intrinsicState) {
        if (!flyweights.containsKey(intrinsicState)) {
            Flyweight flyweight = new ConcreteFlyweight(intrinsicState);
            flyweights.put(intrinsicState, flyweight);
        }
        return flyweights.get(intrinsicState);
    }
}  </code></pre><p>   测试</p>
<pre><code>public class Client {

    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight flyweight1 = factory.getFlyweight(&quot;aa&quot;);
        Flyweight flyweight2 = factory.getFlyweight(&quot;aa&quot;);
        flyweight1.extrinsicState(&quot;x&quot;);
        flyweight2.extrinsicState(&quot;y&quot;);
    }
}</code></pre><p>   结果</p>
<pre><code>Object address: 985934102
IntrinsicState: aa
ExtrinsicState: x
Object address: 985934102
IntrinsicState: aa
ExtrinsicState: y</code></pre><h3 id="JDK使用："><a href="#JDK使用：" class="headerlink" title="JDK使用："></a>JDK使用：</h3><p>Java 利用缓存来加速大量小对象的访问时间。</p>
<ul>
<li>java.lang.Integer#valueOf(int)</li>
<li>java.lang.Boolean#valueOf(boolean)</li>
<li>java.lang.Byte#valueOf(byte)</li>
<li>java.lang.Character#valueOf(char)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2019/01/24/java/java-design/structure/flyweight/" data-id="ckam2zs2y0032meq3epwc0g67" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/javase/hashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/01/08/java/javase/hashMap/" class="article-date">
  <time datetime="2019-01-08T00:00:00.000Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/JavaSE/">JavaSE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/01/08/java/javase/hashMap/">JDK1.8 HashMap源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener">Hashmap的结构，1.7和1.8有哪些区别，史上最深入的分析</a><br><a href="https://www.cnblogs.com/Hangtutu/p/9251999.html" target="_blank" rel="noopener">jdk1.7死环</a><br><a href="https://juejin.im/post/5a66a08d5188253dc3321da0" target="_blank" rel="noopener">jdk1.7线程不安全</a><br><a href="https://blog.csdn.net/u013494765/article/details/77837338" target="_blank" rel="noopener">jdk1.8扩容核心-链表复制处理</a></p>
<h1 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h1><p><img src="/uploads/java/javase/hashMap.png" alt="hashMap继承关系"></p>
<h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><pre><code>// Hash表结构
transient Node&lt;K,V&gt;[] table;

// 保证 fail-fast机制
transient int modCount;

// 下一次扩容时的阈值 (capacity * load factor).
int threshold;

// 负载因子，决定hash表的数据填充程度，此值越大说明hash表填充的越满，空间利用率高，但是增加了查询开销，此值若太小，hash表空间利用率不高且rehash更加频繁
final float loadFactor;    

// 默认初始容量,必须是2的次方
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16

// 最大容量，1的30次方，因为int类型32位，去掉一位符号位，只能左移30位
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

// 默认负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;

// jdk1.8增加 链表转红黑树的阈值
static final int TREEIFY_THRESHOLD = 8;

// jdk1.8增加 红黑树转链表的阈值
static final int UNTREEIFY_THRESHOLD = 6;</code></pre><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>HashMap一共有4个构造方法，主要的工作就是完成容量和加载因子的赋值。Hash表都是采用的<strong>懒加载</strong>方式，当第一次插入数据时才会创建。</p>
<pre><code>// 指定默认容量和负载因子   
public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        // 找到大于等于initialCapacity的最小的2的幂  若传入6 threshold=8
        this.threshold = tableSizeFor(initialCapacity);
}

// 使用默认负载因子
public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

// 参数全部都是默认值
public HashMap() {
       this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}

// 构造一个新的 HashMap与指定的相同的映射 Map 。 
public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
}</code></pre><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="添加一个元素put-K-k-V-v"><a href="#添加一个元素put-K-k-V-v" class="headerlink" title="添加一个元素put(K k,V v)"></a>添加一个元素put(K k,V v)</h2><p>HashMap允许K和V都为null，添加一个键值对时使用put方法，如果之前已经存在K的键值，那么旧值将会被新值替换。</p>
<pre><code>// return 前一个值与key相关联 ，或null如果没有key的映射。 （A null返回也可以指示以前关联的地图null与key。 
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
}

//先来看看hash方法，采用了Object的hash算法返回的是对象的内存地址,每个对象在内存中地址不一样，所以他们的hash值也不一样，不同的算法hashCode不同。
// 这里使用右移操作是为了让高位也参与运算提高散射率。低16位与高16位异或作为key的最终hash值。
// （h &gt;&gt;&gt; 16，表示无符号右移16位，高位补0，任何数跟0异或都是其本身，因此key的hash值高16位不变。） 
// 为什么要这么干呢？ 这个与HashMap中table下标的计算有关。n = table.length; index = （n-1） &amp; hash;因为，table的长度都是2的幂，因此index仅与hash值的低n位有关，hash值的高位都被与操作置为0了。 
// key为null 默认为0即数组第一个
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}

/**
 * @param hash key的Hash值 经过高位与地位的异或运算
 * @param key 
 * @param value 
 * @param onlyIfAbsent 如果是，则不要更改现有值
 * @param evict 如果为false，则表处于创建模式。
 * @return 返回旧值或者null值。
 */        
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        // 如果哈希表的长度为空 调用resize()扩容方法 n为表长度
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        // 如果当前数组下标为null值， (i = (n - 1) &amp; hash]即计算数组下标)，数组当前下标新建一个节点，即为头结点
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        // 数组上该位置有值,桶处有节点，发生hash冲突
        else {
            Node&lt;K,V&gt; e; K k;
            // 如果头结点的值与添加的值一致，hash冲突后，key的值也一致，进行替换。将e指向p
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            // 如果与头节点不同，并且该桶目前已经是红黑树状态，调用putTreeVal()方法 
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            // 如果与头节点不同,桶中仍是链表阶段
            else {
                // 循环遍历链表
                for (int binCount = 0; ; ++binCount) {
                // 讲e指向下一个节点，如果是null，说明该桶中只有头节点，直接添加到链表尾部即可
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        // 如果此时链表个数达到了8，那么需要将该桶处链表转换成红黑树，treeifyBin()方法将hash处的桶转成红黑树
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    //如果与已有节点相同，跳出循环
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            // 存在重复key进行覆盖
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                // 子类实现 linkHashMap 
                afterNodeAccess(e);
                return oldValue;
            }
        }
        //是一个全新节点，那么size需要+1
        ++modCount;
        // 如果大小朝阳了阈值，需要扩容
        if (++size &gt; threshold)
            resize();
        //子类实现    
        afterNodeInsertion(evict);
        return null;
}</code></pre><p>putVal()方法的流程：</p>
<ul>
<li>1.若hash表为空，调用resize方法创建。</li>
<li>2.若桶的头结点为空，创建新结点放在数组中作为链表的头结点。</li>
<li>3.若头节点不为空，即发生hash冲突，取出头结点与当前值判断，若重复直接覆盖；</li>
<li>4.若不重复且当前处于红黑树状态，调用putTreeVal()方法；若不重复且当前处于链表阶段，遍历链表直到找到重复节点或者链表尾部，把该节点插入尾部；存在重复key就跳出循环。</li>
<li>5.存在重复key，进行value替换。</li>
<li>6.扩容验证。</li>
</ul>
<h2 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h2><p>resize()在哈希表为null时将会初始化，但是在已经初始化后就会进行容量扩展</p>
<pre><code>final Node&lt;K,V&gt;[] resize() {
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;// 旧表容量
        int oldThr = threshold;// 旧表的扩容阈值
        int newCap, newThr = 0;
        // 旧表存在
        if (oldCap &gt; 0) {
            // 容量已达上限 
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            // 否则新容量与新阈值都扩大2倍
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        / /如果就阈值&gt;0，说明构造方法中指定了容量
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        // 初始化时没有指定阈值和容量，使用默认的容量16和阈值16*0.75=12    
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        //如果新的阈值为 0 ，就得用 新容量*加载因子 重计算一次
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        //常见扩容后的hash表
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        // 属于扩容
        if (oldTab != null) {
            //遍历旧表 
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                // 当前位置有值
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    //如果只有一个节点，直接在新表中赋值
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        //如果旧哈希表中这个位置的桶是树形结构，就要把新哈希表里当前桶也变成树形结构
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order 保留旧哈希表桶中链表的顺序
                        // 通过e.hash &amp; oldCap将链表分为两队，参考知乎上的一段解释 
                        /** 
                        * 把链表上的键值对按hash值分成lo和hi两串，lo串的新索引位置与原先相同[原先位j]，hi串的新索引位置为[原先位置j+oldCap]； 
                        * 链表的键值对加入lo还是hi串取决于 判断条件if ((e.hash &amp; oldCap) == 0)，因为* capacity是2的幂，所以oldCap为10...0的二进制形式，若判断条件为真，意味着 
                        * oldCap为1的那位对应的hash位为0，对新索引的计算没有影响（新索引 
                        * =hash&amp;(newCap-*1)，newCap=oldCap&lt;&lt;2）；若判断条件为假，则 oldCap为1的那位* 对应的hash位为1， 
                        * 即新索引=hash&amp;( newCap-1 )= hash&amp;( (oldCap&lt;&lt;2) - 1)，相当于多了10...0， 
                        * 即 oldCap 
                        * 例子： 
                        * 旧容量=16，二进制10000；新容量=32，二进制100000 
                        * 旧索引的计算： 
                        * hash = xxxx xxxx xxxy xxxx 
                        * 旧容量-1 1111 
                        * &amp;运算 xxxx 
                        * 新索引的计算： 
                        * hash = xxxx xxxx xxxy xxxx 
                        * 新容量-1 1 1111 
                        * &amp;运算 y xxxx 
                        * 新索引 = 旧索引 + y0000，若判断条件为真，则y=0(lo串索引不变)，否则y=1(hi串 
                        * 索引=旧索引+旧容量10000) 
                           */  
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            // 双链表 尾插法 
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
}</code></pre><p>resize()首先获取新容量以及新阈值，然后根据新容量创建新表。如果是扩容操作，则需要进行rehash操作，通过e.hash&amp;oldCap将链表分为两列，更好地均匀分布在新表中。     </p>
<h2 id="get-K-k-操作"><a href="#get-K-k-操作" class="headerlink" title="get(K k)操作"></a>get(K k)操作</h2><p>get(K k)根据键得到值，如果值不存在，那么返回null</p>
<pre><code>public V get(Object key) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }

final Node&lt;K,V&gt; getNode(int hash, Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    // hash表不为空且第一个节点存在
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) {
        // 第一个节点即为要查询的节点
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        // 链表不止一个头节点    
        if ((e = first.next) != null) {
            // 首节点是红黑树节点，调用getTreeNode方法
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            // 首节点是链表,循环遍历链表
            do {
                // 匹配就返回
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}  </code></pre><p>getNode()过程：</p>
<ul>
<li>1.如果hash表为空或者长度为0或找不到hash值对应的数组位置，返回null</li>
<li>2.如果头节点匹配，返回头结点。</li>
<li>3.如果头结点不匹配且没有后续节点，返回null</li>
<li>4.如果头结点不匹配且头结点是红黑树类型，调用getTreeNode方法寻找节点</li>
<li>5.如果头结点不匹配且头结点是链表结构，从前往后遍历，找到相应的节点就返回</li>
</ul>
<h2 id="remove-操作"><a href="#remove-操作" class="headerlink" title="remove()操作"></a>remove()操作</h2><p>remove(K k)用于根据键值删除键值对，如果哈希表中存在该键，那么返回键对应的值，否则返回null。  </p>
<pre><code>public V remove(Object key) {
    Node&lt;K,V&gt; e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}

final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
    // 当前hash表存在且长度大于0且数组中存在头结点
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (p = tab[index = (n - 1) &amp; hash]) != null) {
        Node&lt;K,V&gt; node = null, e; K k; V v;
        // 头节点即为key所对应的节点，node即为头节点
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            node = p;
        // 头结点有下一个节点    
        else if ((e = p.next) != null) {
            // 首节点是红黑树节点，调用getTreeNode方法
            if (p instanceof TreeNode)
                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
            else {
                // 首节点是链表,遍历链表
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key ||
                         (key != null &amp;&amp; key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        //如果存在待删除节点节点
        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                             (value != null &amp;&amp; value.equals(v)))) {
            //如果节点是TreeNode，使用红黑树的方法                 
            if (node instanceof TreeNode)
                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
            //如果待删除节点是头节点，更改桶中的头节点即可    
            else if (node == p)
                tab[index] = node.next;
            //在链表遍历过程中，p代表node节点的前驱节点    
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}   </code></pre><p>总体来说，removeNode（）先查出待删除的节点，查找过程与查询过程类型，只不过多了在遍历链表时还需要保存前驱节点，因为后面删除时要用到（单链表结构）。存在待删除节点，接下来再执行删除操作.</p>
<ul>
<li>1.如果待删除节点是TreeNode，那么调用removeTreeNode()方法 </li>
<li>2.如果待删除节点是Node，并且待删除节点就是头节点，那么将头节点更改为原有节点的下一个节点就可以了 </li>
<li>3.如果待删除节点是Node且待删除节点不是头节点，那么将遍历过程中保存的前驱节点p的后继节点设为node的后继节点就可以了</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2019/01/08/java/javase/hashMap/" data-id="ckam2zs280027meq3146dfbk3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/blog/">&amp;laquo; Prev</a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><a class="page-number" href="/blog/page/4/">4</a><a class="page-number" href="/blog/page/5/">5</a><a class="extend next" rel="next" href="/blog/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/JavaSE/">JavaSE</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/active/">active</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/cache/">cache</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/database/">database</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/datastructure/">datastructure</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/java-design-patterns/">java-design-patterns</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/linux-command/">linux-command</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/servlet/">servlet</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/tool/">tool</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">日常问题记录</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/02/">February 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2020/04/10/other/hangzhoumetro2025/">杭州地铁规划2025</a>
          </li>
        
          <li>
            <a href="/blog/2020/01/11/java/javase/streamApiAction/">java 1.8  steam流操作</a>
          </li>
        
          <li>
            <a href="/blog/2019/12/20/active/miaosha/">秒杀场景</a>
          </li>
        
          <li>
            <a href="/blog/2019/12/06/spring/beanLifeCycle/">Spring Bean 生命周期</a>
          </li>
        
          <li>
            <a href="/blog/2019/12/06/spring/springLoadXml/">Spring 加载XML文件的六种方式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Marcher<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>