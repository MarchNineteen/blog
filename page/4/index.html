<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Marcher</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Marcher">
<meta property="og:url" content="https://marchnineteen.github.io/page/4/index.html">
<meta property="og:site_name" content="Marcher">
<meta property="article:author" content="Marcher">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Marcher" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Marcher</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://marchnineteen.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-linux-command/rm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018/10/29/linux-command/rm/" class="article-date">
  <time datetime="2018-10-29T00:00:00.000Z" itemprop="datePublished">2018-10-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/linux-command/">linux-command</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/10/29/linux-command/rm/">rm特殊删除</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="特殊删除"><a href="#特殊删除" class="headerlink" title="特殊删除"></a>特殊删除</h1><h2 id="删除所有-p开头的文件"><a href="#删除所有-p开头的文件" class="headerlink" title="删除所有-p开头的文件"></a>删除所有-p开头的文件</h2><p>rm – -P.* </p>
<p>需要用–进行特殊处理</p>
<h2 id="自定义回收站功能"><a href="#自定义回收站功能" class="headerlink" title="自定义回收站功能"></a>自定义回收站功能</h2><p>myrm(){ D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D;  mv “$@” $D &amp;&amp; echo “moved to $D ok”; }</p>
<p>alias rm=’myrm’</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2018/10/29/linux-command/rm/" data-id="ckam2zs15000mmeq35bjo2bxp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-database/mysql" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018/09/05/database/mysql/" class="article-date">
  <time datetime="2018-09-05T00:00:00.000Z" itemprop="datePublished">2018-09-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/database/">database</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/09/05/database/mysql/">mysql概要</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>提到mysql等数据库，当然绕不开它最基本的概念，数据结构，数据库的索引就是数据结构最好的应用。<br><a href="/2019/01/04/datastructure/index/">对数据结构没有概念的同学请点击</a></p>
<h1 id="一：存储引擎（存储引擎提供不同的存储机制、索引技巧、锁定水平等功能）"><a href="#一：存储引擎（存储引擎提供不同的存储机制、索引技巧、锁定水平等功能）" class="headerlink" title="一：存储引擎（存储引擎提供不同的存储机制、索引技巧、锁定水平等功能）"></a>一：存储引擎（存储引擎提供不同的存储机制、索引技巧、锁定水平等功能）</h1><h2 id="InnoDB与MYISAM比较"><a href="#InnoDB与MYISAM比较" class="headerlink" title="InnoDB与MYISAM比较"></a>InnoDB与MYISAM比较</h2><table>
<thead>
<tr>
<th align="center">功 能</th>
<th align="center">MYISAM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储限制</td>
<td align="center">256TB</td>
<td align="center">64TB</td>
</tr>
<tr>
<td align="center">支持事物</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">支持锁级别</td>
<td align="center">表级锁</td>
<td align="center">表级锁，行级锁</td>
</tr>
<tr>
<td align="center">支持外键</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">支持全文索引</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">支持数索引</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">支持哈希索引</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">支持数据缓存</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<h1 id="二：索引"><a href="#二：索引" class="headerlink" title="二：索引"></a>二：索引</h1><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h2 id="1-B-Tree-索引"><a href="#1-B-Tree-索引" class="headerlink" title="1. B+Tree 索引"></a>1. B+Tree 索引</h2><p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要<strong>对树进行搜索</strong>即可，所以查找速度快很多。</p>
<p>除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<h2 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2. 哈希索引"></a>2. 哈希索引</h2><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
<li>数据量大时，会产生hash冲突，性能降低。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h2 id="3-全文索引"><a href="#3-全文索引" class="headerlink" title="3. 全文索引"></a>3. 全文索引</h2><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>
<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h2 id="4-空间数据索引"><a href="#4-空间数据索引" class="headerlink" title="4. 空间数据索引"></a>4. 空间数据索引</h2><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h1 id="三：数据库拆分"><a href="#三：数据库拆分" class="headerlink" title="三：数据库拆分"></a>三：数据库拆分</h1><h1 id="四：数据库主从与读写分离"><a href="#四：数据库主从与读写分离" class="headerlink" title="四：数据库主从与读写分离"></a>四：数据库主从与读写分离</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2018/09/05/database/mysql/" data-id="ckam2zs0j000ameq348qvh7df" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/javase/regularExpression" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018/08/28/java/javase/regularExpression/" class="article-date">
  <time datetime="2018-08-28T00:00:00.000Z" itemprop="datePublished">2018-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/JavaSE/">JavaSE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/08/28/java/javase/regularExpression/">java正则表达式例子</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="正则表达式-文本框输入内容控制"><a href="#正则表达式-文本框输入内容控制" class="headerlink" title="[正则表达式]文本框输入内容控制"></a>[正则表达式]文本框输入内容控制</h1><ul>
<li>整数或者小数：^[0-9]+.{0,1}[0-9]{0,2}$</li>
<li>只能输入数字：”^[0-9]*$”。</li>
<li>只能输入n位的数字：”^\d{n}$”。</li>
<li>只能输入至少n位的数字：”^\d{n,}$”。</li>
<li>只能输入m~n位的数字：。”^\d{m,n}$”</li>
<li>只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。</li>
<li>只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。</li>
<li>只能输入有1~3位小数的正实数：”^[0-9]+(.[0-9]{1,3})?$”。</li>
<li>只能输入非零的正整数：”^+?[1-9][0-9]*$”。</li>
<li>只能输入非零的负整数：”^-[1-9][]0-9”*$。</li>
<li>只能输入长度为3的字符：”^.{3}$”。</li>
<li>只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。</li>
<li>只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。</li>
<li>只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。</li>
<li>只能输入由数字和26个英文字母组成的字符串：”^[A-Za-z0-9]+$”。</li>
<li>只能输入由数字、26个英文字母或者下划线组成的字符串：”^\w+$”。</li>
<li>验证用户密码：”^[a-zA-Z]\w{5,17}$”正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。</li>
<li>验证是否含有^%&amp;’,;=?$&quot;等字符：”[^%&amp;’,;=?$\x22]+”。</li>
<li>只能输入汉字：”^[\u4e00-\u9fa5]{0,}$”</li>
<li>验证Email地址：”^\w+([-+.]\w+)<em>@\w+([-.]\w+)*.\w+([-.]\w+)</em>$”。</li>
<li>验证InternetURL：”^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$”。</li>
<li>验证电话号码：”^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$”正确格式为：”XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX”。</li>
<li>验证身份证号（15位或18位数字）：”^\d{15}|\d{18}$”。</li>
<li>验证一年的12个月：”^(0?[1-9]|1[0-2])$”正确格式为：”01”～”09”和”1”～”12”。</li>
<li>验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01”～”09”和”1”～”31”。</li>
<li>匹配中文字符的正则表达式： [\u4e00-\u9fa5]</li>
<li>匹配双字节字符(包括汉字在内)：[^\x00-\xff]</li>
<li>应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</li>
<li>String.prototype.len=function(){return this.replace(/[^\x00-\xff]/g,”aa”).length;}</li>
<li>匹配空行的正则表达式：\n[\s| ]*\r</li>
<li>匹配html标签的正则表达式：&lt;(.<em>)&gt;(.</em>)&lt;/(.<em>)&gt;|&lt;(.</em>)/&gt;</li>
<li>匹配首尾空格的正则表达式：(^\s<em>)|(\s</em>$)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2018/08/28/java/javase/regularExpression/" data-id="ckam2zs2a002ameq39vkl26wv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/javase/exception" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018/08/08/java/javase/exception/" class="article-date">
  <time datetime="2018-08-08T00:00:00.000Z" itemprop="datePublished">2018-08-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/JavaSE/">JavaSE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/08/08/java/javase/exception/">java异常体系结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java异常体系结构图"><a href="#java异常体系结构图" class="headerlink" title="java异常体系结构图"></a>java异常体系结构图</h1><p><img src="/uploads/java/javase/%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB.png" alt="java异常体系结构"></p>
<p>从图中可以发现（列出要点，简要说明）：</p>
<ul>
<li>所以异常类的父类为Throwable类（表示可抛出），直接继承为Error和Exception两个子类，Error也是异常的一种。</li>
<li>Error是程序无法处理的错误，它是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。</li>
<li>RuntimeException（也称不检查异常）：即可以编译通过，一般由程序的逻辑错误引起，开发过程中应尽量避免。例如：NullPointerException，IndexOutOfBoundsException等。<strong>自定义异常一般继承此类</strong>。</li>
<li>RuntimeException以外的异常（IOException）：编译器在编译阶段进行处理，程序必须处理此类异常否则无法通过编译。</li>
</ul>
<h1 id="try-catch-finally-return"><a href="#try-catch-finally-return" class="headerlink" title="try-catch-finally-return"></a>try-catch-finally-return</h1><p>具体例子见(个人demo):</p>
<blockquote>
<p><a href="https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/java/exception/ReturnFinallyTest.java" target="_blank" rel="noopener">https://github.com/MarchNineteen/spring-example/blob/master/spring-example-test/src/main/java/com/wyb/test/java/exception/ReturnFinallyTest.java</a></p>
</blockquote>
<h1 id="自定义全局异常处理（配套源码）"><a href="#自定义全局异常处理（配套源码）" class="headerlink" title="自定义全局异常处理（配套源码）"></a>自定义全局异常处理（配套源码）</h1><blockquote>
<p><a href="https://github.com/MarchNineteen/spring-example/tree/master/spring-example-exception" target="_blank" rel="noopener">https://github.com/MarchNineteen/spring-example/tree/master/spring-example-exception</a></p>
</blockquote>
<h1 id="常见的异常打印信息"><a href="#常见的异常打印信息" class="headerlink" title="常见的异常打印信息"></a>常见的异常打印信息</h1><ul>
<li>getMessage(): 返回此throwable的详细消息字符串，只会获得具体的异常名称，比如说NullPoint 空指针,就告诉你说是空指针。</li>
<li>printStackTrace():提供对打印的堆栈跟踪信息的编程访问,会打出详细异常,异常名称,出错位置,便于调试用。</li>
<li>toString():返回此throwable的简短描述。</li>
</ul>
<h2 id="注意要点："><a href="#注意要点：" class="headerlink" title="注意要点："></a>注意要点：</h2><ul>
<li>多个catch模块，子类在先，为了保证所有的catch都有存在的意义</li>
<li>finally模块在try-catch的return或者异常处理之前执行</li>
<li>在以下4种特殊情况下，finally块不会被执行：<br>1）在finally语句块中抛出了异常且未处理。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）CPU出现异常被关闭。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2018/08/08/java/javase/exception/" data-id="ckam2zs270026meq35hw0621q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/javase/dataType" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018/05/17/java/javase/dataType/" class="article-date">
  <time datetime="2018-05-17T00:00:00.000Z" itemprop="datePublished">2018-05-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/JavaSE/">JavaSE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/17/java/javase/dataType/">java数据类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-Java-八大基本数据类型及其封装器类（位数为二进制位）"><a href="#1-Java-八大基本数据类型及其封装器类（位数为二进制位）" class="headerlink" title="1.Java 八大基本数据类型及其封装器类（位数为二进制位）"></a>1.Java 八大基本数据类型及其封装器类（位数为二进制位）</h1><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>char：默认值：\u0000，16位，数据范围：\u0000 - u\ffff，存储Unicode码，用单引号赋值。封装类：Character</p>
<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>boolean：默认值：false，1位，只有true和false两个取值。封装类：Boolean</p>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>整数类型：(最大存储容量为2的n次方减一，范围为负数2的n减一次方至2的n减一次方减一，n为位数，原理见计算机组成原理无符号数与有符号数)</p>
<p>byte：默认值：0，8位，字节，最大存储数据量是255，存放的数据范围是-128~127之间。封装类：Byte</p>
<p>short：默认值：0，16位，最大数据存储量是65536，数据范围是-32768~32767之间。封装类：Short</p>
<p>int：默认值：0，32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。封装类：Integer</p>
<p>long：默认值：0，64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。封装类：Long</p>
<p>浮点数类型：</p>
<p>float：默认值：0.0f，32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。封装类：Float</p>
<p>double：默认值：0.0d，64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。封装类：Double</p>
<p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：</p>
<p>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</p>
<p>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</p>
<p>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</p>
<p>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</p>
<blockquote>
<p>注意：float、double两种类型的最小值与Float.MIN_VALUE、 Double.MIN_VALUE的值并不相同，实际上Float.MIN_VALUE和Double.MIN_VALUE分别指的是 float和double类型所能表示的最小正数。也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。</p>
</blockquote>
<h1 id="2-数据类型之间的转换："><a href="#2-数据类型之间的转换：" class="headerlink" title="2.数据类型之间的转换："></a>2.数据类型之间的转换：</h1><h2 id="简单类型数据间的转换"><a href="#简单类型数据间的转换" class="headerlink" title="简单类型数据间的转换"></a>简单类型数据间的转换</h2><p>自动转换：运算或者方法调用时，低精度自动转化为高精度，从低到高顺序：(byte，short，char)–int–long–float—double；<br>        特例：int到float，long到float，long到double 是不会自动转换的，不然将会丢失精度。</p>
<p>强制转换：高精度转为低精度，可以使用强制转换；即你必须采用下面这种语句格式： int n=(int)3.14159/2;可以想象，这种转换肯定可能会导致溢出或精度的下降。</p>
<h2 id="表达式的数据类型自动提升"><a href="#表达式的数据类型自动提升" class="headerlink" title="表达式的数据类型自动提升"></a>表达式的数据类型自动提升</h2><p>注意一下规则：</p>
<pre><code>①所有的byte,short,char型的值将被提升为int型；
②如果有一个操作数是long型，计算结果是long型；
③如果有一个操作数是float型，计算结果是float型；
④如果有一个操作数是double型，计算结果是double型；
例， byte b; b=3; b=(byte)(b*3);//必须声明byte。 </code></pre><h2 id="包装类过渡类型转换"><a href="#包装类过渡类型转换" class="headerlink" title="包装类过渡类型转换"></a>包装类过渡类型转换</h2><ul>
<li>简单类型的变量转换为相应的包装类，可以利用包装类的构造函数。即：Boolean(boolean value)、Character(char value)、Integer(int value)、Long(long value)、Float(float value)、Double(double value)</li>
<li>在各个包装类中，总有形为××Value()的方法，来得到其对应的简单类型数据。利用这种方法，也可以实现不同数值型变量间的转换，例如，对于一个双精度实型类，intValue()可以得到其对应的整型变量，而doubleValue()可以得到其对应的双精度实型变量</li>
</ul>
<h2 id="字符串与其它类型间的转换"><a href="#字符串与其它类型间的转换" class="headerlink" title="字符串与其它类型间的转换"></a>字符串与其它类型间的转换</h2><p>其它类型向字符串的转换：</p>
<pre><code>①调用类的串转换方法:X.toString();
②自动转换:X+&quot;&quot;;
③使用String的方法:String.valueOf(X);</code></pre><p>字符串作为值,向其它类型的转换：</p>
<pre><code>①先转换成相应的封装器实例,再调用对应的方法转换成其它类型。例：new Float(&quot;11&quot;).doubleValue()
②静态parseXXX方法。
    String s = &quot;1&quot;;
    byte b = Byte.parseByte( s );
    short t = Short.parseShort( s );
    int i = Integer.parseInt( s );
    long l = Long.parseLong( s );
    Float f = Float.parseFloat( s );
    Double d = Double.parseDouble( s );
③Character的getNumericValue(char ch)方法</code></pre><h2 id="自动拆箱与自动装箱"><a href="#自动拆箱与自动装箱" class="headerlink" title="自动拆箱与自动装箱"></a><strong>自动拆箱与自动装箱</strong></h2><p>自动装箱：把基本类型用它们对应的包装类包装起来，使它们具有对象的特质，可以调用所对应的包装类所定义的方法，比如toString()等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i0 &#x3D; new Integer(0);&#x2F;&#x2F;基本的创建封装类对象</span><br><span class="line">Integer i1 &#x3D; 2;&#x2F;&#x2F;自动装箱</span><br><span class="line">Integer i1_ &#x3D; Integer.valueOf(2);&#x2F;&#x2F;自动装箱的本质，调用XX.valueof()方法</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line"></span><br><span class="line">自动拆箱：跟自动装箱的方向相反，将Integer及Double这样的包装类的对象重新简化为基本类型的数据(自动拆箱时，一定要确保包装类的引用不为空)</span><br></pre></td></tr></table></figure>
<p>System.out.println(i1+2);<br>//i1是我们上面通过自动装箱得到的一个integer对象，而这个对象是不能直接进行四则运算的，但是我们却给它+2，<br>这样就必须将integer对象转变为基本数据类型（int），这个过程就是自动拆箱的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">jdk装箱池（方法区中的常量池）：java的八种基本类型（Byte Short、Integer、Long、Character、Boolean、Float、Double），除Float及Double意外，其它六种都实现了常量池，但是他们只在大于等于-128且小于等于127时才能使用常量池，如果不在此范围内，则会new一个出来，保存在堆内存中。</span><br><span class="line"></span><br><span class="line">例子：</span><br></pre></td></tr></table></figure>
<pre><code>Integer a = 1;
Integer b = 1;
Integer c = 144;
Integer d = 144;
Integer a1 = new Integer(1);
Integer b1 = new Integer(1);
System.out.println(a == b);         //true
System.out.println(a.equals(b));    //true
System.out.println(a1 == b1);       //false
System.out.println(a1.equals(b1));  //true
System.out.println(c == d);         //false
System.out.println(c.equals(d));    //true</code></pre><pre><code>
在进行==比较的时候，在自动装箱池范围内的数据的引用是相同的，范围外的是不同的。 

# 3.Java引用类型
Java有 5种引用类型（对象类型）：类 接口 数组 枚举 标注
引申：Java中的堆内存、栈内存、静态存储区
&gt; http://www.cnblogs.com/mingziday/p/4899212.html

栈（stack）存放基础数据类型以及对象的对象的引用

堆（heap）存放由new创建的对象和数组，即堆主要是用来存储对象的

方法区中的静态存储区存储static声明的静态变量

# 4.java字符编码
&gt; http://kxjhlele.iteye.com/blog/333211
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2018/05/17/java/javase/dataType/" data-id="ckam2zs260024meq3b76mbxwb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/javase/javaKeyWord" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018/05/16/java/javase/javaKeyWord/" class="article-date">
  <time datetime="2018-05-16T00:00:00.000Z" itemprop="datePublished">2018-05-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/JavaSE/">JavaSE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/16/java/javase/javaKeyWord/">java标识符与关键字</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><ul>
<li><p>概念：就是用于给程序中的变量、类、方法命名的符号;</p>
</li>
<li><p>标识符规则：标识符可以有字母、数字、下划线_、和美元符号$组成，并且数字不能打头<br>   标识符不能使java关键字和保留字，但可以包含关键字和保留字<br>   标识符不能包含空格 标识符只能包含美元符号$，不能包含@、#等其他特殊字符</p>
</li>
<li><p>分隔符：分号; 花括号{} 方括号[] 括号() 空格 圆点.;</p>
</li>
</ul>
<h1 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h1><p>java中包含50个关键，所有关键字都是小写的</p>
<pre><code>关键字列表：
 abstract抽象的            assert 
 boolean                   break 
 byte                      case
 catch                     char
 const(保留字)             continue
default                    do
 double                    else
 enum                      extends
 final                     finally
 float                     for
 if                        goto(保留字)
 implements                import
 int                       interface
 long                      native
 new                       package
 private                   protected
 public                    return 
 short                     static 
 strictfp                  super
 switch                    synchronized
 this                      throw
 throws                    transient
 try                       void 
 volatile                  while

 三个特殊的直接量（iteral）;true false null 都不是关键字


 final、finally、finalize的区别:
 final:
 final修饰变量，则等同于常量,变量不能修改
 final修饰方法中的参数，称为最终参数，参数不能修改。
 final修饰类，则类不能被继承
 final修饰方法，则方法不能被重写。
 finally:
 try-catch模块中使用finally，表示finally块则是无论异常是否发生，都会执行finally块的内容
 finalize:
 使用finalize在垃圾收集器确定这个对象未被引用时调用，表示在垃圾收集器将对象从内存中清除出去之前做一些清理工作。
 子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2018/05/16/java/javase/javaKeyWord/" data-id="ckam2zs290028meq3fqoqa02r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux-command/ls" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/05/linux-command/ls/" class="article-date">
  <time datetime="2017-07-05T00:00:00.000Z" itemprop="datePublished">2017-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/linux-command/">linux-command</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/07/05/linux-command/ls/">ls指令学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h1><p>ls [选项] [目录名]</p>
<h1 id="命令功能："><a href="#命令功能：" class="headerlink" title="命令功能："></a>命令功能：</h1><p>列出目标目录中所有的子目录和文件。</p>
<h1 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h1><ul>
<li><p>-a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件</p>
</li>
<li><p>-A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。  </p>
</li>
<li><p>-c  配合 -lt：根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序</p>
</li>
<li><p>-C 每栏由上至下列出项目</p>
</li>
<li><p>–color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一</p>
</li>
<li><p>-d, –directory 将目录象文件一样显示，而不是显示其下的文件。</p>
</li>
<li><p>-D, –dired 产生适合 Emacs 的 dired 模式使用的结果</p>
</li>
<li><p>-f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</p>
</li>
<li><p>-g 类似 -l,但不列出所有者   </p>
</li>
<li><p>-G, –no-group 不列出任何有关组的信息</p>
</li>
<li><p>-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)</p>
</li>
<li><p>–si 类似 -h,但文件大小取 1000 的次方而不是 1024</p>
</li>
<li><p>-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地</p>
</li>
<li><p>–indicator-style=方式 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</p>
</li>
<li><p>-i, –inode 印出每个文件的 inode 号</p>
</li>
<li><p>-I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目</p>
</li>
<li><p>-k 即 –block-size=1K,以 k 字节的形式表示文件的大小。</p>
</li>
<li><p>-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</p>
</li>
<li><p>-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息</p>
</li>
<li><p>-m 所有项目以逗号分隔，并填满整行行宽</p>
</li>
<li><p>-o 类似 -l,显示文件的除组信息外的详细信息。   </p>
</li>
<li><p>-r, –reverse 依相反次序排列</p>
</li>
<li><p>-R, –recursive 同时列出所有子目录层</p>
</li>
<li><p>-s, –size 以块大小为单位列出所有文件的大小</p>
</li>
<li><p>-S 根据文件大小排序</p>
</li>
<li><p>–sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：</p>
<p>  extension -X status -c</p>
<p>  none -U time -t</p>
<p>  size -S atime -u</p>
<p>  time -t access -u</p>
<p>  version -v use -u</p>
</li>
<li><p>-t 以文件修改时间排序</p>
</li>
<li><p>-u 配合 -lt:显示访问时间而且依访问时间排序 配合 -l:显示访问时间但根据名称排序否则：根据访问时间排序</p>
</li>
<li><p>-U 不进行排序;依文件系统原有的次序列出项目</p>
</li>
<li><p>-v 根据版本进行排序</p>
</li>
<li><p>-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值</p>
</li>
<li><p>-x 逐行列出项目而不是逐栏列出</p>
</li>
<li><p>-X 根据扩展名排序</p>
</li>
<li><p>-1 每行只列出一个文件</p>
</li>
<li><p>–help 显示此帮助信息并离开</p>
</li>
<li><p>–version 显示版本信息并离开</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2017/07/05/linux-command/ls/" data-id="ckam2zs14000lmeq3d1eh7nk8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring/springMVC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/05/spring/springMVC/" class="article-date">
  <time datetime="2017-07-05T00:00:00.000Z" itemprop="datePublished">2017-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/07/05/spring/springMVC/">Spring MVC入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-架构"><a href="#1-架构" class="headerlink" title="1.架构"></a>1.架构</h1><ul>
<li><p>1.1架构图<br><img src="http://images2015.cnblogs.com/blog/932062/201609/932062-20160909153624488-530274633.png" alt="架构天"></p>
</li>
<li><p>1.2架构流程</p>
</li>
</ul>
<p>1.用户发送请求至前端控制器DispatcherServlet</p>
<p>2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>
<p>3.处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>
<p>4.DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</p>
<p>5.执行处理器(Controller，也叫后端控制器)。</p>
<p>6.Controller执行完成返回ModelAndView</p>
<p>7.HandlerAdapter将controller执行结果ModelAndView返回</p>
<p>8.DispatcherServlet</p>
<p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</p>
<p>9.ViewReslover解析后返回具体View</p>
<p>10.DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</p>
<p>11.DispatcherServlet响应用户</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2017/07/05/spring/springMVC/" data-id="ckam2zs1c0011meq3erhy64wm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring/springXMLSchema" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/05/spring/springXMLSchema/" class="article-date">
  <time datetime="2017-07-05T00:00:00.000Z" itemprop="datePublished">2017-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/07/05/spring/springXMLSchema/">springXMLSchema</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>出处 <a href="http://www.jianshu.com/p/1e35c15d0cb8" target="_blank" rel="noopener">http://www.jianshu.com/p/1e35c15d0cb8</a></p>
</blockquote>
<blockquote>
<p>参考资料 <a href="http://www.w3school.com.cn/schema/index.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/schema/index.asp</a></p>
</blockquote>
<h1 id="自己理解整理："><a href="#自己理解整理：" class="headerlink" title="自己理解整理："></a>自己理解整理：</h1><ul>
<li>基本概念：</li>
</ul>
<p>XML Schema也被称为XML Schema定义（XML Schema Definition，XSD）。和DTD一样，Schema也是XML的约束，同样用于定义合法的XML文档构建模块。与DTD不同的是，XML Schema是用一套预先定义好的XML元素和属性创建的，这些元素和属性规定了XML文档的结构和内容模式，且XML Schema规定XML文档实例的结构和每一个元素或属性的数据类型。另外，Schema相对于DTD有一个明显的好处就是，Schema是基于XML编写的，自己本身也是一个XML文档（文件后缀名为.xsd），而不是像DTD有自成一套的语法，这也是Schema能比DTD更被广泛应用的原因。</p>
<ul>
<li>名称空间：</li>
</ul>
<p>在编写了一个XML Schema约束文档后，通常需要把这个文档定义的元素和属性绑定到一个URI地址上，这个地址就叫做名称空间。接着XML文档通过这个名称空间告诉解析引擎，文档中的元素和属性来自哪里。名称空间有什么用呢？就是用来唯一标识元素和属性来自哪个Schema。简单来说，当一个XML实例文档引用了多个Schema的时候，倘若这些Schema定义了同名的元素或属性，名称空间就可以将它们区分开来。</p>
<p>引用其他Schema</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-bd466d293a47249c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="引用其他Schema"></p>
<p>自定义schema 给自己的文件命名方便其他文件调用</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-575c97f367170ff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-09a4197ec412e170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>xmlns后的属性即表示该文件中的context属性来源于这个ns</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-09a4197ec412e170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-000dac2e6124f4d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>修改XML实例文档:</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-e87ee2b5f0532d77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-20e2d37ed4275474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2017/07/05/spring/springXMLSchema/" data-id="ckam2zs1f0012meq3gr9e3i0m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/javase/collection" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/03/16/java/javase/collection/" class="article-date">
  <time datetime="2017-03-16T00:00:00.000Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/JavaSE/">JavaSE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/03/16/java/javase/collection/">java集合框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p><img src="http://upload-images.jianshu.io/upload_images/4942449-cc7c288a15f6c092?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="集合框架体系图"></p>
<h2 id="Set-extends-Collection"><a href="#Set-extends-Collection" class="headerlink" title="Set (extends Collection)"></a>Set (extends Collection)</h2><p>Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 Set接口主要实现了两个实现类：</p>
<ul>
<li>HashSet： HashSet类按照哈希算法来存取集合中的对象，存取速度比较快</li>
<li>TreeSet ：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。</li>
<li>LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。</li>
</ul>
<h2 id="List-extends-Collection"><a href="#List-extends-Collection" class="headerlink" title="List (extends Collection)"></a>List (extends Collection)</h2><p>实际上有两种List: 一种是基本的ArrayList,其优点在于随机访问元素，另一种是更强大的LinkedList,它并不是为快速随机访问设计的，而是具有一套更通用的方法。</p>
<p>List : 次序是List最重要的特点：它保证维护元素特定的顺序。List为Collection添加了许多方法，使得能够向List中间插入与移除元素(这只推荐LinkedList使用。)一个List可以生成ListIterator,使用它可以从两个方向遍历List,也可以从List中间插入和移除元素。</p>
<ul>
<li>ArrayList : 由数组实现的List。允许对元素进行快速随机访问，但是向List中间插入与移除元素的速度很慢。ListIterator只应该用来由后向前遍历ArrayList,而不是用来插入和移除元素。因为那比LinkedList开销要大很多。</li>
<li>LinkedList : 对顺序访问进行了优化，向List中间插入与删除的开销并不大。随机访问则相对较慢。(使用ArrayList代替。)还具有下列方法：addFirst(), addLast(), getFirst(), getLast(), removeFirst() 和 removeLast(), 这些方法 (没有在任何接口或基类中定义过)使得LinkedList可以当作堆栈、队列和双向队列使用。</li>
</ul>
<h2 id="Queen-extends-Collection"><a href="#Queen-extends-Collection" class="headerlink" title="Queen (extends Collection)"></a>Queen (extends Collection)</h2><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>方法put(Object key, Object value)添加一个“值”(想要得东西)和与“值”相关联的“键”(key)(使用它来查找)。方法get(Object key)返回与给定“键”相关联的“值”。可以用containsKey()和containsValue()测试Map中是否包含某个“键”或“值”。标准的Java类库中包含了几种不同的Map：HashMap, TreeMap, LinkedHashMap, WeakHashMap, IdentityHashMap。它们都有同样的基本接口Map，但是行为、效率、排序策略、保存对象的生命周期和判定“键”等价的策略等各不相同。</p>
<p>执行效率是Map的一个大问题。看看get()要做哪些事，就会明白为什么在ArrayList中搜索“键”是相当慢的。而这正是HashMap提高速度的地方。HashMap使用了特殊的值，称为“散列码”(hash code)，来取代对键的缓慢搜索。“散列码”是“相对唯一”用以代表对象的int值，它是通过将该对象的某些信息进行转换而生成的。所有Java对象都能产生散列码，因为hashCode()是定义在基类Object中的方法。</p>
<p>HashMap就是使用对象的hashCode()进行快速查询的。此方法能够显着提高性能</p>
<p>Map : 维护“键值对”的关联性，使你可以通过“键”查找“值”</p>
<ul>
<li>HashMap : Map基于散列表的实现。插入和查询“键值对”的开销是固定的。可以通过构造器设置容量capacity和负载因子load factor，以调整容器的性能。</li>
<li>LinkedHashMap : 类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(LRU)的次序。只比HashMap慢一点。而在迭代访问时发而更快，因为它使用链表维护内部次序。</li>
<li>TreeMap : 基于红黑树数据结构的实现。查看“键”或“键值对”时，它们会被排序(次序由Comparabel或Comparator决定)。TreeMap的特点在于，你得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。</li>
<li>WeakHashMao : 弱键(weak key)Map，Map中使用的对象也被允许释放: 这是为解决特殊问题设计的。如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。</li>
<li>IdentifyHashMap : 使用==代替equals()对“键”作比较的hash map。专为解决特殊问题而设计</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/4942449-9e051ab63d770a2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="总结如下："><a href="#总结如下：" class="headerlink" title="总结如下："></a>总结如下：</h2><p><img src="http://upload-images.jianshu.io/upload_images/4942449-51c43e347a13527d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>他们之间的区别：<br><img src="http://upload-images.jianshu.io/upload_images/4942449-6c1ae30630a5a608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h1 id="集合框架初始化容量和扩容比较："><a href="#集合框架初始化容量和扩容比较：" class="headerlink" title="集合框架初始化容量和扩容比较："></a>集合框架初始化容量和扩容比较：</h1><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ArrayList</th>
<th align="left">LinkList</th>
<th align="left">HashMap</th>
<th align="left">HashTable</th>
</tr>
</thead>
<tbody><tr>
<td align="left">jdk1.7</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">初始容量</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">扩容条件</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">扩容大小</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">最大容量</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">jdk1.8</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">初始容量</td>
<td align="left">10</td>
<td align="left"></td>
<td align="left">1 &lt;&lt; 4(16)</td>
<td align="left">11</td>
</tr>
<tr>
<td align="left">扩容条件</td>
<td align="left">在第一次add时扩容检测</td>
<td align="left"></td>
<td align="left">扩容加载因子为(0.75)，第一个临界点在当HashMap中元素的数量大于table数组长度<em>加载因子（16</em>0.75=12）</td>
<td align="left">扩容加载因子(0.75)，当超出默认长度（int）（11*0.75）=8时</td>
</tr>
<tr>
<td align="left">扩容大小</td>
<td align="left">oldCapacity + (oldCapacity &gt;&gt; 1)，即大约原集合长度的1.5倍</td>
<td align="left"></td>
<td align="left">oldThr &lt;&lt; 1(原长度*2)</td>
<td align="left">old*2+1(代码int newCapacity = (oldCapacity &lt;&lt; 1) + 1)</td>
</tr>
<tr>
<td align="left">最大容量</td>
<td align="left">Integer.MAX_VALUE - 8</td>
<td align="left"></td>
<td align="left">1 &lt;&lt; 30</td>
<td align="left">Integer.MAX_VALUE - 8</td>
</tr>
</tbody></table>
<p>对于java中的各种集合类，根据底层的具体实现，小结了一下大致有3种扩容的方式：</p>
<p>1、对于以散列表为底层数据结构实现的，（譬如hashset，hashmap，hashtable等），扩容方式为当链表数组的非空元素除以数组大小超过加载因子时，链表数组长度变大（乘以2+1），然后进行重新散列。</p>
<p>2、对于以数组为底层数据结构实现的，譬如ArrayList，当数组满了之后，数组长度变大 oldCapacity + (oldCapacity &gt;&gt; 1)，然后将原数组中的数据复制到新数组中。</p>
<p>3、对于以链表结构实现的，譬如TreeSet，TreeMap，则是动态增加元素~~即每次加１即可。</p>
<h2 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h2><p><strong>为啥arrayList最大值是Integer.MAX_VALUE - 8</strong>：<br>数组作为一个对象，需要一定的内存存储对象头信息，对象头信息最大占用内存不可超过8字节。</p>
<h2 id="部分源码实现过程："><a href="#部分源码实现过程：" class="headerlink" title="部分源码实现过程："></a>部分源码实现过程：</h2><h3 id="hashMap-put过程"><a href="#hashMap-put过程" class="headerlink" title="hashMap put过程"></a>hashMap put过程</h3><p>1.判断hash表是否为空，为空resize()方法创建表<br>2.根据hash值获得hash表中桶的头结点，若头结点为空直接调用newNode()添加结点<br>3.如果发生了hash冲突，先得到头结点进行比较，如果相同，替换节点值<br>4.如果头结点头结点不相同，且此时已处于红黑树状态，调用putTreeVal()添加入树中<br>5.如果还是处于链表状态，从头开始遍历链表，一旦找到相同的结点，就跳出循环，若到链表末尾，则添加一个结点<br>6.若添加后达到红黑树的阈值，则转换为红黑树(从treeifyBin方法可以看到，当容量小于64时，不会进行红黑树转换，只会扩容)<br>7.如果是添加一个数据，size将加一，如果达到阈值，则resize()扩容</p>
<h3 id="hashMap-resize"><a href="#hashMap-resize" class="headerlink" title="hashMap resize"></a>hashMap resize</h3><p>首先获取新容量以及新阈值，然后根据新容量创建新表。如果是扩容操作，则需要进行rehash操作，通过e.hash&amp;oldCap将链表分为两列，更好地均匀分布在新表中。 </p>
<h3 id="linkList-中间插入过程"><a href="#linkList-中间插入过程" class="headerlink" title="linkList 中间插入过程"></a>linkList 中间插入过程</h3><p>例：在A，B两个连续结点中插入C结点,形成ACB</p>
<p>1.创建一个新结点，将新节点的后继指针指向B，前继指针指向A<br>2.将B的前指针指向C<br>3.根据A是否为空判断，A为空该节点为头结点，重置first结点；不为空A的后指针指向C</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://marchnineteen.github.io/2017/03/16/java/javase/collection/" data-id="ckam2zs250023meq3ckztgjzp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/blog/page/3/">&amp;laquo; Prev</a><a class="page-number" href="/blog/">1</a><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/blog/page/5/">5</a><a class="extend next" rel="next" href="/blog/page/5/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/JavaSE/">JavaSE</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/active/">active</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/cache/">cache</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/database/">database</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/datastructure/">datastructure</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/java-design-patterns/">java-design-patterns</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/linux-command/">linux-command</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/servlet/">servlet</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/tool/">tool</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">日常问题记录</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/02/">February 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2020/04/10/other/hangzhoumetro2025/">杭州地铁规划2025</a>
          </li>
        
          <li>
            <a href="/blog/2020/01/11/java/javase/streamApiAction/">java 1.8  steam流操作</a>
          </li>
        
          <li>
            <a href="/blog/2019/12/20/active/miaosha/">秒杀场景</a>
          </li>
        
          <li>
            <a href="/blog/2019/12/06/spring/beanLifeCycle/">Spring Bean 生命周期</a>
          </li>
        
          <li>
            <a href="/blog/2019/12/06/spring/springLoadXml/">Spring 加载XML文件的六种方式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Marcher<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>